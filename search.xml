<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>逆向分析-Base64</title>
      <link href="/2021/12/28/ni-xiang-fen-xi-base64/"/>
      <url>/2021/12/28/ni-xiang-fen-xi-base64/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> 关于Base64的原理和加解密网上多的是，想要加解密一段字符串也可以到在线网站上去找，<a href="http://tool.chinaz.com/tools/base64.aspx">Base64</a> 就是其中一个，不过Base64解密工具在解密Base64时默认的标准串都是ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/，所以本偏博客的目的就是分享一个脚本，当标准串改变时能够根据所给的标准串进行编码和解码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>#coding:utf-8import reimport base64import stringimport randomdef base64_encode(s, dictionary):   r = ""   p = ""   c = len(s) % 3   if (c &gt; 0):       for i in range(c, 3):           p += '='           s += "\0"   for c in range(0, len(s), 3):       n = (ord(s[c]) &lt;&lt; 16) + (ord(s[c+1]) &lt;&lt; 8) + (ord(s[c+2]))       n = [(n &gt;&gt; 18) &amp; 0x3F, (n &gt;&gt; 12) &amp; 0x3F, (n &gt;&gt; 6) &amp; 0x3F, n &amp; 0x3F]       r += dictionary[n[0]] + dictionary[n[1]] + dictionary[n[2]] + dictionary[n[3]]   return r[0:len(r) - len(p)]  + pdef base64_decode(s, dictionary):   base64inv = {}   for i in range(len(dictionary)):       base64inv[dictionary[i]] = i   s = s.replace("\n", "")   if not re.match(r"^([{alphabet}]{{4}})*([{alphabet}]{{3}}=|[{alphabet}]{{2}}==)?$".format(alphabet = dictionary), s):       raise ValueError("Invalid input: {}".format(s))   if len(s) == 0:       return ""   p = "" if (s[-1] != "=") else "AA" if (len(s) &gt; 1 and s[-2] == "=") else "A"   r = ""   s = s[0:len(s) - len(p)] + p   for c in range(0, len(s), 4):       n = (base64inv[s[c]] &lt;&lt; 18) + (base64inv[s[c+1]] &lt;&lt; 12) + (base64inv[s[c+2]] &lt;&lt; 6) + base64inv[s[c+3]]       r += chr((n &gt;&gt; 16) &amp; 255) + chr((n &gt;&gt; 8) &amp; 255) + chr(n &amp; 255)   return r[0:len(r) - len(p)]def test_base64():   dictionary = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"   def random_string(length):       return ''.join(random.choice(string.ascii_letters) for m in range(length))   for i in range(100):       s = random_string(i)       encoded = base64_encode(s, dictionary)       assert(encoded == base64.b64encode(s))       assert(s == base64_decode(encoded, dictionary))if __name__ == "__main__":  dictionary =  "加解密的base64标准串"    //根据不同题目自行修改Base64的标准串  print(base64_decode("需要解密的内容", dictionary))    print(base64_encode("需要加密的内容",dictionary))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓逆向破解--欢乐切水果大作战</title>
      <link href="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/"/>
      <url>/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-Killer软件配置"><a href="#Android-Killer软件配置" class="headerlink" title="Android Killer软件配置"></a>Android Killer软件配置</h2><ul><li>配置Java SDK环境<br>注意安装路径是你电脑上jdk根目录下的bin文件夹<img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image1.jpg" class=""></li><li>更新ApkTool<br>到ApkTool官方网站 <a href="https://ibotpeaches.github.io/Apktool/">ApkTool</a> 上下载最新版本的ApkTool,把下载好的jar文件放到AndroidKiller根目录下的bin\apktool\apktool里面，然后返回到上一级目录bin\apktool去修改apktool.bat和apktool.ini两个文件的内容，把使用的ApkTool修改成刚刚下载的那个<img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image2.jpg" class=""></li></ul><h2 id="欢乐切水果大乱斗"><a href="#欢乐切水果大乱斗" class="headerlink" title="欢乐切水果大乱斗"></a>欢乐切水果大乱斗</h2><ul><li><p>我们破解修改这个软件的目的是修改apk文件里面和支付程序，让我们不充钱也可以购买装备，先在模拟器里面打开游戏点击充值看一下有什么提示，切记不要真充钱了</p><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image3.jpg" class=""></li><li><p>提示信息支付失败，所以我们用 Android Killer 打开apk文件，在工程搜索，搜索字符里面输入字符串’失败’，然后文本转unicode再搜索，不然直接以文本’失败’搜索的话找不到我们需要的函数  </p><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image4.jpg" class=""></li><li><p>在上图中发现定义的三个跟支付有关的函数 payResultCancel,payResultSuccess,payResultFalse,所以软件应该是根据你支付的情况分别跳转到这三个相应的函数，那就好办了，如果我们让程序无论用户支付成功还是失败都跳转到 payResultSuccess 函数里面岂不美哉  </p></li><li><p>在图中工程管理器所示的路径下找到 MiGuSdkPay$1.smali ,发现里面正好有根据我们的支付行为选择跳转到 payResultCancel,payResultSuccess,payResultFalse 三个相应函数里面的关键代码。至于是怎么发现关键函数在 MiGuSdkPay$1.smali 里面的，emmmm我一个一个点开看的…..  </p><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image5.jpg" class=""></li><li><p>我们把根据相应支付行为跳转到的函数都改成 payResultSuccess 函数  </p><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image6.jpg" class=""></li><li><p>然后下一步我们还可以在搜索框搜索游戏的名字 ‘欢乐切水果大作战’，然后把它修改为我们自己想定义的名字。然后点击主菜单栏Android 下的编译进行生成。- 当然你也可以修改其他的东西，包括图片音乐啥的，但是我现在技术还连入门都算不上，所以暂时还不会，等日后会的再来完善，现在我们用模拟器看看修改后的效果。</p></li><li><p>白嫖成功！逆向果然刑！！！</p></li></ul><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image7.jpg" class=""><p>-</p>]]></content>
      
      
      
        <tags>
            
            <tag> Game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向分析--对称加密RC4</title>
      <link href="/2021/12/02/ni-xiang-fen-xi-dui-cheng-jia-mi-rc4/"/>
      <url>/2021/12/02/ni-xiang-fen-xi-dui-cheng-jia-mi-rc4/</url>
      
        <content type="html"><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><ul><li>RC4是一种对称的流加密算法，它的密钥长度可变，通过随机数生成的核心与异或运算完成对于数据流的加密。相对于AES，DES对于固定长度数据块加密，RC4输入的plaintext为任意的。RC4的特点是运算速度快，密钥长度为1–256BYTE可变。<br>RC4的核心可以分为对密钥空间s的初始化与密文的交换。</li></ul><h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><ul><li>初始化S盒并用秘钥打乱S盒<pre><code>void rc4_init(unsigned char*s,unsigned char*key,unsigned long len)//s最开始是传入的长度为256的char型空数组，用来存放初始化后的s//key是定义的秘钥  //最后一个len是密钥的长度{   int i=0;   int j=0;   unsigned char k[256]={};   unsigned char temp = 0;  for(i=0;i&lt;256;i++)   {      s[i]=i;         //0-255赋给s       k[i]=key[i%len];   //将k重新计算   }  for(i=0;i&lt;256;i++)  {      j=(j+s[i]+k[i])%256;    //给j赋      temp=s[i];      s[i]=s[j];      s[j]=temp;    //s[i]和s[j]交换   }}</code></pre></li></ul><ul><li>加解密部分，因为是对称加密算法，所以既可加密也可解密</li></ul><pre><code>void rc4_crypt(unsigned char*s,unsigned char*data,unsigned long len)//s是上面初始化之后的，data是我们要加密的数据，len是data的长度{    int i=0,j=0,t=0;    unsigned long k=0;    unsigned char temp;     for(k=0;k&lt;len;k++)    {        i=(i+1)%256;            //固定方式        j=(j+s[i])%256;          //固定方式        temp=s[i];        s[i]=s[j];        s[j]=temp;             //s[i]和s[j]交换        t=(s[i]+s[j])%256;      //固定方式        data[k]^=s[t];          //异或运算，即加解密    }}</code></pre><ul><li>main函数,初始化S盒后另外用一个s2把S盒的值存下来，因为加密后S盒的内容会再次打乱</li></ul><pre><code>int main(){    unsigned char s[256] = {0};//s来接收初始化后的s,用来加密    unsigned char s2[256] = {0};//用来存放初始化后的s，解密可用    char key[256] = {"just a test"};//密钥    char data[512] = {"要加密的数据"};    unsigned long len = strlen(data);    rc4_init(s,(unsigned char*)key,strlen(key));    for(i=0;i&lt;256;i++)    {       s2[i] = s[i];  //存放加密后的s    }    rc4_crypt(s,(unsigned char*)data,len);//加密    rc4_crypt(s,(unsigned char*)data,len);//解密    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向之路的第一周</title>
      <link href="/2021/11/29/ni-xiang-zhi-lu-de-di-yi-zhou/"/>
      <url>/2021/11/29/ni-xiang-zhi-lu-de-di-yi-zhou/</url>
      
        <content type="html"><![CDATA[<h2 id="修改汇编代码"><a href="#修改汇编代码" class="headerlink" title="修改汇编代码"></a>修改汇编代码</h2><h3 id="直接跳转到生成flag的函数"><a href="#直接跳转到生成flag的函数" class="headerlink" title="直接跳转到生成flag的函数"></a>直接跳转到生成flag的函数</h3><ul><li>题目是来自 <a href="https://ctf.bugku.com/">Bugku</a> 里面的一道入门题 <a href="https://ctf.bugku.com/challenges/detail/id/116.html">游戏过关</a>  查壳反汇编不用说了，这道题是让你输入一些数字让程序最终执行到输出flag的函数<br>如果你游戏水平够高你也可以直接通过玩游戏来获取flag，不然的话还是修改汇编代码来的直接，找到main函数，在几个call  sub_45A7BE指令里面随便选一个修改为call  sub_45E940，保存运行即可，当然了前提是你能找到main函数和打印的flag的函数，再次运行exe文件即可得到flag</li></ul><p><img src="http://pic.yupoo.com/wfscjz/1639f889/big.png"></p><h2 id="安卓逆向"><a href="#安卓逆向" class="headerlink" title="安卓逆向"></a>安卓逆向</h2><h3 id="记一下自己逆向路上遇到的第一个安卓逆向题"><a href="#记一下自己逆向路上遇到的第一个安卓逆向题" class="headerlink" title="记一下自己逆向路上遇到的第一个安卓逆向题"></a>记一下自己逆向路上遇到的第一个安卓逆向题</h3><ul><li>题目时来自 <a href="https://ctf.bugku.com/">Bugku</a> 里的一入门题 <a href="https://ctf.bugku.com/challenges/detail/id/136.html">signin</a>,先在模拟器里面运行一下看看效果<br><img src="http://pic.yupoo.com/wfscjz/1ec16f3e/big.png"><br>猜测是一个输入字符然后验证的程序，我们用jeb打开apk文件，找到main函数按Q反编译成java代码<br><img src="http://pic.yupoo.com/wfscjz/eb4bfac8/big.png"><br>main函数里面的getFlag()函数是返回地址为2131427360处的字符串，然后该字符串在checkPassword函数中先被reverse翻转一下，然后base64解码，解码后的内容即为我们想要找的flag，所以问题变成了我们只需要找到地址为2131427360处的字符串即可<br>在apk文件的R类中可以找到地址为2131427360处的字符串命名为”toString”,在string类中，但是我在jeb里面没找到res/values文件夹，所以在百度搜索之后用jadx打开apk文件找到res/values/strings.xml<br><img src="http://pic.yupoo.com/wfscjz/94e4b629/big.png"></li><li>成功找到了字符串，所以后续我们写脚本跑一下即可<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">import</span> base64a <span class="token operator">=</span> <span class="token string">"991YiZWOz81ZhFjZfJXdwk3X1k2XzIXZIt3ZhxmZ"</span>a <span class="token operator">=</span> a<span class="token punctuation">[</span>::-1<span class="token punctuation">]</span>print<span class="token punctuation">(</span>base64.b64decode<span class="token punctuation">(</span>a<span class="token punctuation">))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Buuctf-Reverse3"><a href="#Buuctf-Reverse3" class="headerlink" title="Buuctf Reverse3"></a>Buuctf Reverse3</h2><ul><li><p>查壳扔进IDA反汇编如下<br><img src="https://i.loli.net/2021/12/01/EzD1lFLBG296OIf.png"></p></li><li><p>所以我们反过来求解即可，脚本如下</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">import</span> base64a <span class="token operator">=</span> <span class="token string">"e3nifIH9b_C@n@dH"</span>flag <span class="token operator">=</span> <span class="token string">""</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>a<span class="token punctuation">))</span>:  flag +<span class="token operator">=</span> chr<span class="token punctuation">(</span>ord<span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> - i<span class="token punctuation">)</span>print<span class="token punctuation">(</span>base64.b64decode<span class="token punctuation">(</span>flag<span class="token punctuation">))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Buuctf-不一样的flag"><a href="#Buuctf-不一样的flag" class="headerlink" title="Buuctf 不一样的flag"></a>Buuctf 不一样的flag</h2><ul><li>查壳，反汇编然后走迷宫<br><img src="https://i.loli.net/2021/12/01/i9azrYMSbB2FQxE.png"></li></ul><h2 id="Buuctf-simplere"><a href="#Buuctf-simplere" class="headerlink" title="Buuctf simplere"></a>Buuctf simplere</h2><ul><li>个人感觉这道题主要考察的是大端存储和小端存储，这个如果不知道的话那么这道肯定做不出来 <a href="https://baijiahao.baidu.com/s?id=1609459208102387514">计算机中数据存储方式</a><br>查壳，拖进IDA反汇编，找到Decry()函数<br><img src="https://i.loli.net/2021/12/02/IqpsuYS3KBOVCfv.png"><br>前面的部分主要是生成text和key字符串的，下面是验证输入的过程，所以我们可以写代码反推出flag<br><img src="https://i.loli.net/2021/12/02/xdyrqEYutk6QVHX.png">  </li><li>但是由于源程序代码中还有模26的操作，但我目前没想到更好的办法，所以只能让i从0到4开始爆破，i大于4时范围超了肯定不正确<pre class="line-numbers language-bash"><code class="language-bash">char text<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"killshadow"</span><span class="token punctuation">;</span>  char key<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"adsfkndcls"</span><span class="token punctuation">;</span>  char V1<span class="token punctuation">;</span>  char flag<span class="token punctuation">[</span>10<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  int V3 <span class="token operator">=</span> 10<span class="token punctuation">;</span>  for<span class="token punctuation">(</span> int i<span class="token operator">=</span>0<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>4<span class="token punctuation">;</span>i++<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      for<span class="token punctuation">(</span> int j<span class="token operator">=</span>0<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>10<span class="token punctuation">;</span>j++<span class="token punctuation">)</span>      <span class="token punctuation">{</span>          V1 <span class="token operator">=</span> text<span class="token punctuation">[</span>j<span class="token punctuation">]</span> - 97  + i * 26 + key<span class="token punctuation">[</span>V3++%10<span class="token punctuation">]</span> - 58<span class="token punctuation">;</span>          if<span class="token punctuation">(</span> V1 <span class="token operator">&lt;</span> 90 <span class="token operator">&amp;&amp;</span> V1 <span class="token operator">></span> 65 <span class="token punctuation">)</span>              flag<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> V1<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  cout <span class="token operator">&lt;&lt;</span> flag <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Buuctf-Java逆向解密"><a href="#Buuctf-Java逆向解密" class="headerlink" title="Buuctf Java逆向解密"></a>Buuctf Java逆向解密</h2><ul><li>附件是.class文件，所以直接用jd-gui打开<br><img src="https://i.loli.net/2021/12/02/djfN4bxquEDrHYv.png"></li><li>只是在数后面加上异或的值，java脚本如下</li></ul><pre><code>public static void main(String[] args) {        // TODO Auto-generated method stub        String flag = "" ;        int[] KEY = { 180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65 };        for (int j = 0; j &lt; KEY.length; j++) {          flag += (char)(KEY[j] - '@' ^ 0x20);        }        System.out.print(flag);    }</code></pre><h2 id="Buuctf-刮开有奖"><a href="#Buuctf-刮开有奖" class="headerlink" title="Buuctf 刮开有奖"></a>Buuctf 刮开有奖</h2><ul><li><p>一道输入flag然后对你的输入进行验证的题目，查壳，反汇编，找到关键的函数<br><img src="https://i.loli.net/2021/12/03/FbHoKOafIND7EWX.png"></p></li><li><p>在把sub_4010F0()中的代码转移到编译器里面自己执行时需要修改一些内容，首先(_DWORD <em>)要去除，然后就是</em>( i * 4 + a1)，点击v7,v8等等会发现它们的地址都是相差4，当然这是因为是32位程序导致的，如果是64位程序相差就位8.所以当i等于1时*(1 * 4 + a1) 对应的就是v8的值，是不是很像C++数组里面的 *（a + i ) ,所以在把代码转移到自己的编译器上时，你可以做如下修改 ：</p><p>1 将v7[0] 到 v16 的值用一个长度为11的数组表示</p><p>2 删去(_DWORD *) 和所有的 4 *</p></li><li><p>最后代码如下，跑一下就能出结果</p></li></ul><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int __cdecl sub_4010F0(int *a1, int a2, int a3){  int result; // eax  int i; // esi  int v5; // ecx  int v6; // edx  result = a3;  for ( i = a2; i &lt;= a3; a2 = i )  {    v5 =  i;    v6 = a1[i];    if ( a2 &lt; result &amp;&amp; i &lt; result )    {      do      {        if ( v6 &gt; a1[result] )        {          if ( i &gt;= result )            break;          ++i;          a1[v5] = a1[result];          if ( i &gt;= result )            break;          while ( a1[i] &lt;= v6 )          {            if ( ++i &gt;= result )              goto LABEL_13;          }          if ( i &gt;= result )            break;          v5 =  i;          a1[result] = a1[i];        }        --result;      }      while ( i &lt; result );    }LABEL_13:    a1[result] = v6;    sub_4010F0(a1, a2, i - 1);    result = a3;    ++i;  }  return result;}int main(){    char flag[] = "WP1jMp" ; // v4 和 v5 base64解码    int arry[11] = {90,74,83,69,67,97,78,72,51,110,103};    sub_4010F0(arry,0,10) ;    cout &lt;&lt; "flag{" &lt;&lt; (char)(arry[0] + 34) &lt;&lt; char(arry[4]) &lt;&lt; flag &lt;&lt; "}" ;    return 0;}</code></pre><h2 id="Buuctf-luck-guy"><a href="#Buuctf-luck-guy" class="headerlink" title="Buuctf luck_guy"></a>Buuctf luck_guy</h2><ul><li>查壳，反汇编找到关键函数getflag()<br><img src="https://i.loli.net/2021/12/03/QbDg6eIymoC8XEw.png"></li><li>写代码跑一下即可,提交时把GXY换成flag即可</li></ul><pre><code>s = "icug`of"flag = "GXY{do_not_"for i in range(len(s)):    if i % 2 == 1:       flag += chr(ord(s[i]) - 2 )    else:       flag += chr(ord(s[i]) - 1 )print(flag)</code></pre><h2 id="Buuctf-JustRe"><a href="#Buuctf-JustRe" class="headerlink" title="Buuctf JustRe"></a>Buuctf JustRe</h2><ul><li>直接使用keypatch插件修改汇编代码让点击一次即可即可，当然你点击19999次也能出答案<br><img src="https://i.loli.net/2021/12/03/hSmrnbUAHuTtXCK.png"></li></ul><h2 id="Buuctf-findit"><a href="#Buuctf-findit" class="headerlink" title="Buuctf findit"></a>Buuctf findit</h2><ul><li>这道题的解题方法和 <a href="https://buuoj.cn/challenges#%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96">buuctf 刮开有奖</a> 有点类似，都是转换后的代码转移到自己的编译器里面执行，附件是apk文件，所以用jeb打开，找到对你输入进行验证的语句<br><img src="https://s2.loli.net/2021/12/03/2ynTkYoAZKh5bdI.png"></li></ul><h2 id="Buuctf-简单注册机"><a href="#Buuctf-简单注册机" class="headerlink" title="Buuctf 简单注册机"></a>Buuctf 简单注册机</h2><ul><li>用jeb打开转换成java代码然后把生成flag的语句放到C++/C编译器里面跑一下就行，目前为止最简单的一道题</li></ul><pre><code>char v5[] = "dd2940c04462b4dd7c450528835cca15";    v5[2] = ((char)(v5[2] + v5[3] - 50));    v5[4] = ((char)(v5[2] + v5[5] - 48));    v5[30] = ((char)(v5[31] + v5[9] - 48));    v5[14] = ((char)(v5[27] + v5[28] - 97));    int v4;    for(v4 = 0; v4 &lt; 16; ++v4)    {        char v0 = v5[31 - v4];        v5[31 - v4] = v5[v4];        v5[v4] = v0;    }    cout &lt;&lt; "flag{" &lt;&lt; v5 &lt;&lt; "}" ;</code></pre><h2 id="Buuctf-pyre"><a href="#Buuctf-pyre" class="headerlink" title="Buuctf pyre"></a>Buuctf pyre</h2><ul><li>直接在在线网站 <a href="http://tool.lu/pyc">在线工具</a> 上将pyc文件编译成py文件，然后写脚本结题即可<pre><code>code = [  '\x1f',   '\x12',  '\x1d',  '(',  '0',  '4',  '\x01',  '\x06',  '\x14',  '4',  ',',  '\x1b',  'U',  '?',  'o',  '6',  '*',  ':',  '\x01',  'D',  ';',  '%',  '\x13']for i in range(len(code)-2,-1,-1):   code[i] = chr(ord(code[i]) ^ ord(code[i+1]))flag = ""for i in range(len(code)):  flag += chr( (ord(code[i]) -i) % 128 )print(flag)</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
