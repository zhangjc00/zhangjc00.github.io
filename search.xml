<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>逆向之路的第五周</title>
      <link href="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/"/>
      <url>/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/</url>
      
        <content type="html"><![CDATA[<h2 id="Buuctf-SignIn1"><a href="#Buuctf-SignIn1" class="headerlink" title="Buuctf SignIn1"></a>Buuctf SignIn1</h2><ul><li>这是buuctf里的一道简单题目，<a href="https://buuoj.cn/challenges#[SUCTF2019]SignIn">SignIn1</a></li><li>首先看main函数</li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image1.jpg" class=""> <p>其中__gmpz_init_set_str(a,b,c)函数试将b以c进制的形式存储到a中<br>而__gmpz_powm（a,b,c,d)则是将b的c次方模d然后将结果存储到a中，类似于RSA加密，其实这道题就是让求RSA<br>__gmpz_cmp（a,b)则是比较a，b的值<br>sub_96A()函数则是将输入的V8字符串转换为十六进制然后存储到V9中</p><ul><li>所以这道题就是求__gmpz_powm(v6, v6, v5, v4)中的第二个V6，而V4相当于RSA里面的n，第一个V6是密文C，第二个V6是明文M,V5是e<br>所以先用yafu工具分解一下n</li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image2.jpg" class=""> <ul><li>解密脚本如下 ，得到的十六进进制数转换为字符串即可</li></ul><pre><code>from Crypto.Util.number import *from gmpy2 import *e = 65537n = 103461035900816914121390101299049044413950405173712170434161686539878160984549c = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35p = 366669102002966856876605669837014229419q = 282164587459512124844245113950593348271d = invert( e,(p-1)*(q-1) )m = pow(c,d,p*q)print(m)</code></pre><h2 id="Buuctf-Level1"><a href="#Buuctf-Level1" class="headerlink" title="Buuctf Level1"></a>Buuctf Level1</h2><ul><li><p>这是buuctf里的一道简单题目，<a href="https://buuoj.cn/challenges#[WUSTCTF2020]level1">Level1</a> </p></li><li><p>直接看main函数</p></li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image3.jpg" class=""> <ul><li>分析一下代码，只能说没有比这更简单的了。。。。。,代码如下</li></ul><pre><code>int arry[19] = {198,232,816,200,1536,300,6144,984,51200,570,92160,1200,565248,756,1474560,800,6291456,1782,65536000};    for( int i=1;i&lt;=19;i++)    {        if( (i &amp; 1) != 0 )            arry[i-1] = ( arry[i-1] &gt;&gt; i ) ;        else            arry[i-1] = arry[i-1] / i ;    }    for( int i=0;i&lt;19;i++)        cout &lt;&lt; char(arry[i]) ;</code></pre><h2 id="Buuctf-CrackRtf"><a href="#Buuctf-CrackRtf" class="headerlink" title="Buuctf CrackRtf"></a>Buuctf CrackRtf</h2><ul><li><p>buuctf里的一道题目，<a href="https://buuoj.cn/challenges#CrackRTF">CrackRtf</a></p></li><li><p>查壳发现无壳，32位，所以拖到ida找到main函数，main函数分为两大部分，第一部分如下  </p></li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image4.jpg" class=""> <ul><li>输入一个六位的字符，而后面有atoi()函数，这个函数在C语言里面试将数字转换为字符串，所以得出第一次让输入的是六位的数字，然后通过atoi()函数转换为字符串，再通过strcat()函数将”@DBApp”接到字符串的后面，然后进行加密，再与”6E32D0943418C2C33385BC35A1470250DD8923A9”进行比较。  </li><li>进入加密函数</li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image5.jpg" class=""> <p>一堆看不懂的函数，但是认识一个词hash，所以直接百度搜函数名发现这是CryptCreateHash哈希加密，哈希加密是很多算法放在一起，然后随机抽一个算法来加密，其中决定选取那种加密方式取决于CryptCreateHash()函数的第二个参数<br>查官方文档 <a href="https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id">https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id</a> 可得第一部分和第二部分所采用的加密方式</p><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image6.jpg" class=""> <img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image7.jpg" class=""> <p>第二个md5加密我知道，但是第一个加密函数还没听说过，所以百度搜索了下发现在线网站只有sh1的加密没有在线解密，所以只能网上找脚本</p><pre><code>import hashlibflag2 = "@DBApp"for i in range(100000,999999):    h2 = hashlib.sha1((str(i)+flag2).encode("utf-8"))    flags = h2.hexdigest()    if "6e32d0943418c2c33385bc35a1470250dd8923a9" == flags:            print (str(i)+flag2)            print(flags)</code></pre><p>跑一下得到第一部分的密码 123321@DBApp </p><ul><li>接下来看第二部分</li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image8.jpg" class=""> <ul><li>输入一个长度为六的字符串，然后将第一部分的 123321@DBApp 加到字符串后面再进行md5加密</li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image9.jpg" class=""><p>直接在线解密md5，得到字符串 ~!3a@0123321@DBApp,得到的前六个字符就是第二次要输入的字符，所以运行CrackRTF程序，两次输入password，发现生成一个rtf文件，打开得到flag</p><h2 id="Buuctf-EasyRe1"><a href="#Buuctf-EasyRe1" class="headerlink" title="Buuctf EasyRe1"></a>Buuctf EasyRe1</h2><ul><li>buuctf里的一道题目，<a href="https://buuoj.cn/challenges#[2019%E7%BA%A2%E5%B8%BD%E6%9D%AF]easyRE">easyRE1</a></li><li>打开搜索字符串发现”you found me！”，然后定位所在函数</li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image10.jpg" class=""> <pre><code>a = [73,111,100,108,62,81,110,98,40,111,99,121,127,     121,46,105,127,100,96,51,119,125,119,101,107,     57,123,105,121,61,126,121,76,64,69,67]flag=""for i in range(36):    flag+=chr(a[i]^i)print (flag)</code></pre><p>跑一下得到提示 </p><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image11.jpg" class=""><ul><li>继续往下看你会发现base64加密，兴许你还高兴的直接进行10次base64解密，但是你会发现你中套了，解密后得到的什么也不是</li><li>在百度搜了一下发现主函数下面一个函数才是解题的关键，所以点击主函数下面一个函数</li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image12.jpg" class=""><ul><li>解题脚本如下</li></ul><pre><code>v5 = ''enc1 = 'flag'v2 = ''enc = [0x40,0x35,0x20,0x56,0x5D,0x18,0x22,0x45,0x17,0x2F,0x24,0x6E,0x62,0x3C,0x27,0x54,0x48,0x6C,0x24,0x6E,0x72,0x3C,0x32,0x45,0x5B]for i in range(4):    v5 += chr(enc[i] ^ ord(enc1[i]))print (v5)for i in range(len(enc)):    v2 += chr(enc[i] ^ ord(v5[i%4]))print(v2)</code></pre><h2 id="Buuctf-Transform"><a href="#Buuctf-Transform" class="headerlink" title="Buuctf Transform"></a>Buuctf Transform</h2><ul><li><p>buuctf里的一道题目，<a href="https://buuoj.cn/challenges#[MRCTF2020]Transform">Transform</a></p></li><li><p>查壳发现无壳，主函数如下</p></li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image13.jpg" class=""><ul><li>根据判断条件得到数据</li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image14.jpg" class=""><ul><li>写出解密脚本如下</li></ul><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int main(){    int i;    char c[33];    char a[]= {0x09,0x0a,0x0f,0x17,0x07,0x18,0x0c,0x06,0x01,0x10,0x03,0x11,0x20,0x1d,    0x0b,0x1e,0x1b,0x16,0x04,0x0d,0x13,0x14,0x15,0x02,0x19,0x05,0x1f,0x08,0x12,0x1a,0x1c,0x0e,0} ;    char b[]= {0x67,0x79,0x7b,0x7f,0x75,0x2b,0x3c,0x52,0x53,0x79,0x57,0x5e,0x5d,0x42,    0x7b,0x2d,0x2a,0x66,0x42,0x7e,0x4c,0x57,0x79,0x41,0x6b,0x7e,0x65,0x3c,0x5c,0x45,0x6f,0x62,0x4d};    for(i=0; i&lt;=32; i++)    {        b[i]=b[i]^a[i];    }    for(i=0; i&lt;=32; i++)    {        c[a[i]]=b[i];    }    for(i=0; i&lt;=32; i++)        cout &lt;&lt; c[i] ;    return 0;}</code></pre><h2 id="Buuctf-Youngter-drive"><a href="#Buuctf-Youngter-drive" class="headerlink" title="Buuctf Youngter-drive"></a>Buuctf Youngter-drive</h2><ul><li><p>buuctf里的一道题目，<a href="https://buuoj.cn/challenges#Youngter-drive">Youngter-drive</a></p></li><li><p>打开主函数</p></li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image15.jpg" class=""><ul><li>虽然看不太懂，但是发现了Thread，联想java里面所以这道题应该是和多线程有关，第一处是StartAddress()函数，第二处是sub_41119F()函数</li><li>分析StartAddress()函数</li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image16.jpg" class=""><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image17.jpg" class=""><p>分析一下发现是判断字符大小写然后进行表替换，表为QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbn</p><ul><li>分析sub_41119F()函数</li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image18.jpg" class=""><p>对dword_418008变量进行-1操作，其中dword_418008变量为 1Dh</p><ul><li>分析sub_411190()函数</li></ul><img src="/2022/03/15/ni-xiang-zhi-lu-de-di-wu-zhou/image19.jpg" class=""><p>判断变换后的字符串是否等于 TOiZiZtOrYaToUwPnToBsOaOapsyS ，但这里有一点很奇怪，在最开始判断里面0 – 1D 有30个字符，但后来sub_41119F()函数运行后对dword_418008变量进行-1操作，之后就是0 – 1C 对29个字符进行操作</p><ul><li>脚本如下</li></ul><pre><code>off_418000 = "QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm"off_418004 = "TOiZiZtOrYaToUwPnToBsOaOapsyS"flag=''for i in range(len(off_418004)):    if i %2 == 0:        flag += off_418004[i]        continue    for j,k in enumerate(off_418000):        if off_418004[i] == k:            if chr(j+38).isupper():                flag += chr(j+38)            else:                flag += chr(j+96)print(flag)</code></pre><ul><li>但是这里发只有29位，正是sub_41119F()函数运行后对dword_418008变量进行-1操作导致的，所以最后一个字符只能一个个的爆破，但直接百度找wp得到最后一个字符位”E”</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编堆栈平衡</title>
      <link href="/2022/03/12/hui-bian-dui-zhan-ping-heng/"/>
      <url>/2022/03/12/hui-bian-dui-zhan-ping-heng/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是堆栈平衡"><a href="#什么是堆栈平衡" class="headerlink" title="什么是堆栈平衡"></a>什么是堆栈平衡</h2><p>这里有两种情况：</p><ul><li>如果要返回父程序，则当我们在堆栈中进行堆栈操作的时候，一定要保证在RET这条指令之前，ESP指向的是压入的我们压入的地址<br>这句话我是这么理解的，就是当你调用函数的时候，比如使用CALL指令，当使用堆栈的时候，使用前ESP指向那个地址，使用后RET返回前就必须是那个地址，如果不是那个地址，那么堆栈就是不平衡的，程序就崩溃了。</li></ul><p>直接上图分析一下：</p><img src="/2022/03/12/hui-bian-dui-zhan-ping-heng/image1.jpg" class=""> <p>这个程序运行起来以后一定是会崩溃的，在函数执行结束前，它使用了堆栈，向栈顶push了eax的值，使栈顶指针ESP的值-4，这样ret程序就飞了，因为push把它带到了另一个世界</p><img src="/2022/03/12/hui-bian-dui-zhan-ping-heng/image2.jpg" class=""> <p>运行结果：</p><p>可以看到，反汇编窗口直接没了，原因就是他没有00000003这个地址，程序就这样飞走了，这是第一种情况。</p><img src="/2022/03/12/hui-bian-dui-zhan-ping-heng/image3.jpg" class=""><ul><li>如果通过堆栈传递参数了。那么在程序执行完毕后，要平衡因参数导致的堆栈变化<br>这句话的意思就是，当我们使用堆栈传参的时候，在程序执行完毕后这些参数应该一起被清理掉，也就是加了几条参数，就要在堆栈中加几个地址，这么做可以理解为清理垃圾。</li></ul><p>上图分析一波：</p><p>这是第一次堆栈传参，在程序执行完毕前，堆栈一直都是平衡的，也没有垃圾可以清理，但如果我们需要接着向堆栈中压入数据，那么程序执行完毕后的垃圾就出现了。</p><img src="/2022/03/12/hui-bian-dui-zhan-ping-heng/image4.jpg" class=""><p>这是第二次传参：之前程序执行结束后的参数没有被清理，导致后面的参数直接依次压入栈顶，多使用了两个地址，后边的000000001与000000002我们都不会再用了，但是没有被覆盖掉，这样多几个堆栈传参操作，程序的性能就会越来越差，直至崩溃。</p><img src="/2022/03/12/hui-bian-dui-zhan-ping-heng/image5.jpg" class=""><h2 id="如何进行堆栈平衡"><a href="#如何进行堆栈平衡" class="headerlink" title="如何进行堆栈平衡"></a>如何进行堆栈平衡</h2><ul><li>外方栈</li></ul><p>就是从程序外部加一行代码去平衡堆栈，方法很简单，程序执行结束多用几个地址就多加几个地址。注意观察堆栈的变化。</p><img src="/2022/03/12/hui-bian-dui-zhan-ping-heng/image6.jpg" class=""><ul><li>内平栈</li></ul><p>就是改变ret返回时esp栈顶指针的变化，用几个参数就加几个地址。注意观察堆栈的变化。</p><p>这里向堆栈传递了2个参数，我们在程序执行完毕前加了条ret 8，程序执行完毕后栈顶指针ESP的值就会多+8，这样就完美清理我们传递的那两个参数所占用的地址了。</p><p>运行结果：</p><img src="/2022/03/12/hui-bian-dui-zhan-ping-heng/image7.jpg" class=""><p>参考：<a href="https://blog.csdn.net/qq_43573676/article/details/104376354?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164714491116780265460653%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164714491116780265460653&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-104376354.pc_search_result_cache&amp;utm_term=%E9%80%86%E5%90%91%E8%B0%83%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A1&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/qq_43573676/article/details/104376354?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164714491116780265460653%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164714491116780265460653&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-104376354.pc_search_result_cache&amp;utm_term=%E9%80%86%E5%90%91%E8%B0%83%E5%A0%86%E6%A0%88%E5%B9%B3%E8%A1%A1&amp;spm=1018.2226.3001.4187</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可执行文件的壳</title>
      <link href="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/"/>
      <url>/2022/03/11/ke-zhi-xing-wen-jian-de-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><ul><li>今天来讨论一下PE文件的壳，壳主要用于PE文件的商业保护，以此达到软件不被暴掉的可能性，随着破解知识的普及，软件的壳也愈加复杂还是难以不被暴。  </li><li>壳的一个加载过程:</li></ul><img src="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/image1.jpg" class=""> <p>这张图其实是一种情形，原程序被压缩引擎压过，还可以是在EXE文件上直接加壳不压缩，这样到省了壳的大小，但原EXE代码没有压缩，反而变大了一点，还有一种是在EXE文件的节区的空隙中添加，这样压缩过的文件和原文件一样大，但是对节区的大小有要求。这是三种常规的加壳思路。<br>如果单单是加一个简单的壳，象罗云彬的《windows32位环境下的汇编语言程序设计》中的那个AddCode就是一个典型代表。主要步骤如下：<br>首先在节区表上添加一个节区表信息，把代码写到文件的最后面（已经与新的节区表信息对应），主要注意一下，节区的SectionAlignment和FileAlignment，按照这两个参数写节区信息表，跳到节区表中对应文件偏移位置处，写入代码，代码在节区写不满，要填充0，保持文件对齐的值，通常200，最后是收尾工作，PE文件的NumberOfSections加1，SizeOfImage要加上新节区按照SectionAlignment的值对齐后的大小的值，SizeOfHeaders要按照FileAlignment对齐的，如果加上一个IMAGE_SECTION_HEADER，大小不过FileAlignment，就可能不用修改其值的，还有个SizeOfCode是添加代码的大小，就是将含有代码的节区的大小值相加（这个值已经按FileAlignment对齐，载节区表中）。<br>刚才讲的是上面说的第二个思路，还有两个思路，在下面的附件中有个与此类似的思路的一个，还有个是第三个思路的方法。<br>上面的这个方法实现是比较简单的，但是这种方法没有什么程序保护功能，下面讲一下又保护功能的方法。<br>要实现保护功能，可以保护的内容常见的有，导入函数，导出函数，代码段，数据段等。</p><ol><li>如何实现导入函数的保护。<br>在PE文件的头中的DataDirectory有个导入函数的列表，指定RVA和大小，许多PE文件分析，如PEID，LoadPE，还有我的PE Scanner,都是根据这里找到函数的信息的。<br>这个RVA，在PE文件加载后，会指定到一个IMAGE_IMPORT_DESCRIPTOR,这个结构如下：</li></ol><pre><code>typedef struct _IMAGE_IMPORT_DESCRIPTOR {    union {        DWORD   Characteristics;            // 0 for terminatin gnull import descriptor        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)    } DUMMYUNIONNAME;    DWORD   TimeDateStamp;                  // 0 if not bound,date\time stamp                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)                                            // O.W. date/time stamp of DLL bound to (Old BIND)     DWORD   ForwarderChain;                 // -1 if no forwarders    DWORD   Name;    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)} IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</code></pre><p>在这个结构体中OriginalFirstThunk和FirstThunk虽然不指同一位置，但是它们指向的ThunkData所知的位置是相同的，等于一个是另一个的备份，在Windows的装载器加载时，会将FirstThunk指向的所有的ThunkData替换成ThunkData指向的函数的真正的地址，如下图：</p><img src="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/image2.jpg" class=""> <p>在程序未加载时，可以看到磁盘文件如下：</p><img src="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/image3.jpg" class=""> <p>402014的位置是000020F4，这个是RVA，在看这个ThunkData指向哪里，如下：</p><img src="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/image4.jpg" class=""> <p>可以看出再过去两个字节就是ExitProcess的函数名，这是个IMAGE_IMPORT_BY_NAME的结构，前两个字节是HINT，是个无关紧要的WORD字段，大致熟悉了一下PE的加载原理，如果自己写保护导入表的保护的话，这些过程需要自己代码“手动”完成。</p><img src="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/image5.jpg" class=""> <p>这些402014的位置已经被填充数据，而不再是原来的RVA，000020F4，<br>JMP DWORD DS：[402014]<br>也就成了：</p><p>JMP 754879f8<br>再看看754879f8处的数据：</p><img src="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/image6.jpg" class=""> <p>可以看到这里到了Kernel32中的ExitProcessStub，整个加载过程也就明了了。<br>2.如何加载“藏”的导入表<br>因此如果要保护输入表里的函数，就必须把原来的导入表的那些信息（包括IMAGE_IMPORT_DESCRIPTOR和一系列的ThunkData）“藏”起来，自己定义一个IMAGE_IMPORT_DESCRIPTOR和ThunkData，用于定义自己必须的API函数，这样自己就不用再堆中找Kernel32的基址，查导出函数等一系列的复杂工作，比如自己定义两个位于Kernel32.dll中的函数，LoadLibraryA和GetProcAddressA，自己把原来的导入函数信息表“藏”了起来，自己在程序加载时要把找出来，并且在FirstThunk中找函数，因为导入表被“藏”，PE的装载器没有为程序将ThunkData的值换成居如754879f8等这样的真正的函数地址，所以自己要找函数（有按序号导入的和按名称导入的两种），需要注意的是若找到的函数是序号导入的话，需去掉高位用于检测的1（即与80000000H检测），然后直接将其作为函数的名称，用GetProcAddressA来获取地址，DLL的名称获取更加简单，直接，用Name的RVA加基址，即可，获取DLL名称的字符串，可用LoadLibraryA，来加载。<br>通过上面这些步骤，使 比如先前的 402014的这些位置，自己用LoadLibrary加载Kernel32.dll，获取ExitProcess的地址，并且把得到的地址填到402014的位置处，这样ExitProcess函数才得以顺利执行，其他的函数其次类推，要把所有的IMAGE_IMPORT_DESCRIPTOR找遍，保证所有的函数地址都被填到恰当的位置。<br>3. 关于加密数据和代码<br>上面的这些方法，其实只保护了导入表，但只要有点反汇编的人都能知道前面的代码，因为程序的入口虽改变，但是代码任在那里，可以改变偏移即可看到，如下两个对比图：<br>没有加密代码段的情况（start处是我的代码）：</p><img src="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/image7.jpg" class=""> <p>加密代码段的情况（start是我的代码）：</p><img src="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/image8.jpg" class=""> <p>加密代码段的情况下，需要在自己的代码里有揭秘代码的内容，以便代码得以执行，我的这个例子只是简单的转位，rol,ror,所以揭秘相当简单，如果要复杂的话，可以用压缩引擎压缩代码，这样还能更多节省空间，还可以用其他的密码学原理来加密等，具体细节，自由发挥。<br>但是这种加密还是不太十分靠得住的，ASPack，UPX，Pecompact等，还有附件中我自己编写的这个，用的都是这种方法。<br>这种类型壳非常好脱，下面举个例子：</p><img src="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/image9.jpg" class=""> <p>这是个ASPack的壳，刚开始的时候，断点处push后面的还是0，到此处已经变为004013da，这个正是原来程序的ep，其实ASPack前面的工作跟我的那个壳差不多，无非就是填充ThunkData和揭秘数据。</p><img src="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/image10.jpg" class=""> <p>到此处，可见，ASPack吧所有的ThunkData都填充了，用OllyDump顺便dump下，在看一下，导入表信息，借助LoadPE将其中的NtDllDefWindowProc_A改成DefWindowProcA，程序脱壳完成。<br>这种壳之所以好脱，是因为，外壳代码，在程序揭秘后又将代码写到原来的位置，如果设计一种机制，这个机制是每次需要执行代码时，先读取加密的数据，揭秘一条指令长的数据，然后再执行，然后再取，再揭秘，在执行，这个循环的过程一直执行下去，直到最后，而且用的空间只是一个指令长的地址空间，后面执行的代码覆盖前面的代码，短的指令，填充90H(nop)，这样揭秘的数据不会记录，提高了安全性，但这个方法，需要面临下个数据的指令的长度，就需要个小型反汇编引擎嵌在壳上，还有eip改动到的位置等的问题，所以就复杂点了。<br>4. 虚拟机的构想<br>上面的问题引起这个问题的产生，虚拟机就是模仿CPU指令执行，I/O环境等的一种机制，这种机制在虚拟机软件较常见，如：vmware，vbox等，壳也可以用虚拟机这种机制，只不过他主要模仿CPU的指令，也可模仿I/O环境等，将上面的机制设置的复杂一点，如：pop eax，转到虚拟机执行，变成，dec eax，inc eax转到虚拟机变成push eax，还可以更复杂，自己模拟一个I/O环境，每次IN 45H，表示eax加1，每次IN 46H表示eax减去1，IN 50H表示ebx加1等等。<br>虚拟机还可以参入密码学加密机制，等。<br>虚拟机不一定非要模仿原来的机器指令集，还可以自己制定一套专用指令集，指令集要有可行性，就是原来机器指令都能被执行。指令集越古怪反而越能增加壳的安全性，但是千万不可出错，要有系统性，否则调试会很棘手。</p><p>总的来说，内容较多，涉及范围较广，而且若要设计起来，将是一个大的工程，估计壳的添加代码也较多。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><ul><li>upx的壳，官网地址<a href="https://upx.github.io/">https://upx.github.io/</a><br>这种壳很常见，应该是技术已经很纯熟了，加壳、脱壳利用官网发布的工具可以轻松实现。<br>程序参数如下</li></ul><img src="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/image11.jpg" class=""> <ul><li>MPRESS壳，官网地址<a href="http://www.matcode.com/mpress.htm">http://www.matcode.com/mpress.htm</a><br>这种壳官网提供的程序只有加壳功能，不具备脱壳功能，不过可以使用OD+esp定律轻松脱壳</li></ul><p>一：执行过pushad，数据窗口中找到esp地址的值，该值处下硬件访问断点(读断点)</p><img src="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/image12.jpg" class=""> <p>二、F9运行至上面下的断点，如果遇到jmp指令就一直F8步过，直到遇到程序真正的入口</p><img src="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/image13.jpg" class=""> <p>三、插件—&gt;OllyDump—&gt;脱壳在当前调试的进程，点击脱壳(面板中的数字不懂含义的话，尽量不要修改)，给脱壳后的程序选一个保存位置、选个新名字就完成脱壳了。</p><img src="/2022/03/11/ke-zhi-xing-wen-jian-de-ke/image14.jpg" class=""> <ul><li>参考来源</li></ul><p><a href="https://blog.csdn.net/wangyunfeis/article/details/77454038">https://blog.csdn.net/wangyunfeis/article/details/77454038</a></p><p><a href="https://bbs.pediy.com/thread-224537.htm">https://bbs.pediy.com/thread-224537.htm</a></p><p><a href="https://blog.csdn.net/baccon/article/details/39762959?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164714319216780265457300%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164714319216780265457300&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-39762959.pc_search_result_cache&amp;utm_term=%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%A3%B3&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/baccon/article/details/39762959?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164714319216780265457300%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164714319216780265457300&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-39762959.pc_search_result_cache&amp;utm_term=%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%A3%B3&amp;spm=1018.2226.3001.4187</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向之路的第四周</title>
      <link href="/2022/03/10/ni-xiang-zhi-lu-de-di-si-zhou/"/>
      <url>/2022/03/10/ni-xiang-zhi-lu-de-di-si-zhou/</url>
      
        <content type="html"><![CDATA[<h2 id="Buuctf-xor"><a href="#Buuctf-xor" class="headerlink" title="Buuctf xor"></a>Buuctf xor</h2><ul><li>这是buuctf里的一道简单题目，<a href="https://buuoj.cn/challenges#[MRCTF2020]Xor">xor</a> ,查壳发现无壳，放进ida里面F5反汇编一下发现出现错误</li></ul><img src="/2022/03/10/ni-xiang-zhi-lu-de-di-si-zhou/image1.jpg" class=""> <ul><li>不能反汇编，这个错误产生的原因一般有两种：<br>IDA无法识别出正确的调用约定。<br>IDA无法识别出正确的参数个数。</li><li>而上面报错时提示的就是call 函数分析失败，所以我们找到 call    sub_401020点击进入，反汇编一下，这时发现main函数也可以反汇编了</li></ul><img src="/2022/03/10/ni-xiang-zhi-lu-de-di-si-zhou/image2.jpg" class=""> <ul><li>最后就是写异或脚本</li></ul><pre><code>tmp=[0x4D,0x53, 0x41, 0x57, 0x42, 0x7E, 0x46, 0x58, 0x5A, 0x3A,0x4A,0x3A, 0x60, 0x74, 0x51, 0x4A, 0x22, 0x4E, 0x40, 0x20,0x62, 0x70, 0x64, 0x64, 0x7D, 0x38, 0x67]flag=""for i in range(27):    print( chr(i^tmp[i]),end = "")</code></pre><h2 id="Buuctf-xxor"><a href="#Buuctf-xxor" class="headerlink" title="Buuctf xxor"></a>Buuctf xxor</h2><ul><li>这是buuctf里的一道简单题目，<a href="https://buuoj.cn/challenges#[GWCTF%202019]xxor">xxor</a></li></ul><img src="/2022/03/10/ni-xiang-zhi-lu-de-di-si-zhou/image3.jpg" class=""><ul><li>分析main函数，主要就是输入六个数据，在经过两次处理后的得到的数据，将其转成16进制再变成字符串，其中我们需要让if里面的值为1，点开sub_400770函数</li></ul><img src="/2022/03/10/ni-xiang-zhi-lu-de-di-si-zhou/image4.jpg" class=""><p>-通过分析得出六个数据<br>xora[0] = 3746099070;<br>xora[1] = 550153460;<br>xora[2] = 3774025685;<br>xora[3] = 1548802262;<br>xora[4] = 2652626477;<br>xora[5] = 2230518816;</p><ul><li>往上走，发现sub_400686(&amp;dword_601078, &amp;unk_601060)函数，这个函数对我们的输入进行</li><li>然后就是unk_601060，里面就四个有用的数据，2，2,3,4，所以我们打开sub_400686(&amp;dword_601078, &amp;unk_601060)函数，分析里面的加密代码，然后逆着写脚本,得到输出数据后将16进制数转换为字符串得到flag</li></ul><pre><code>int main(){    unsigned int xora[6];    xora[0] = 3746099070;    xora[1] = 550153460;    xora[2] = 3774025685;    xora[3] = 1548802262;    xora[4] = 2652626477;    xora[5] = 2230518816;    int i = 0,j=0,sum;    unsigned int temp[2] = {0};    unsigned int data[4] = { 2,2,3,4 };    for (i = 0; i &lt; 5; i += 2)    {        temp[0] = xora[i];        temp[1] = xora[i + 1];        sum = 0x458BCD42 * 64;        for (j = 0; j &lt; 64; j++)        {            temp[1] -= (temp[0] + sum + 20) ^ ((temp[0] &lt;&lt; 6) + 3) ^ ((temp[0] &gt;&gt; 9) + 4) ^ 0x10;            temp[0] -= (temp[1] + sum + 11) ^ ((temp[1] &lt;&lt; 6) + 2) ^ ((temp[1] &gt;&gt; 9) + 2) ^ 0x20;            sum -= 0x458BCD42;        }        xora[i] = temp[0];        xora[i + 1] = temp[1];    }    for (i = 0; i &lt; 6; i++)    printf("%x",xora[i]);}</code></pre><h2 id="Buuctf-hello-world-go"><a href="#Buuctf-hello-world-go" class="headerlink" title="Buuctf hello_world_go"></a>Buuctf hello_world_go</h2><ul><li><p>这是buuctf里的一道简单题目，<a href="https://buuoj.cn/challenges#[MRCTF2020]hello_world_go">hello_world_go</a></p></li><li><p>我们直接把文件的后缀名改为.txt，然后查找flag</p></li></ul><img src="/2022/03/10/ni-xiang-zhi-lu-de-di-si-zhou/image5.jpg" class=""><h2 id="Buuctf-level3"><a href="#Buuctf-level3" class="headerlink" title="Buuctf level3"></a>Buuctf level3</h2><ul><li><p>这是buuctf里的一道题目，<a href="https://buuoj.cn/challenges#[WUSTCTF2020]level3">level3</a></p></li><li><p>无壳，拖入IDA反汇编分析发现就是变种的base64加密</p></li></ul><img src="/2022/03/10/ni-xiang-zhi-lu-de-di-si-zhou/image7.jpg" class=""><ul><li>然后是变化后的base64码表</li></ul><img src="/2022/03/10/ni-xiang-zhi-lu-de-di-si-zhou/image6.jpg" class=""><ul><li>解密函数</li></ul><pre><code>import base64table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='model = list("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=")s = "d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD=="for i in range(10):    model[i], model[19-i] = model[19-i], model[i]model = ''.join(model)table = str.maketrans(model, table)print (base64.b64decode(s.translate(table)))</code></pre><h2 id="Buuctf-lgnitiMe"><a href="#Buuctf-lgnitiMe" class="headerlink" title="Buuctf lgnitiMe"></a>Buuctf lgnitiMe</h2><ul><li><p>这是buuctf里的一道题目，<a href="https://buuoj.cn/challenges#[FlareOn4]IgniteMe">lgniteMe</a></p></li><li><p>查壳发现无壳，所以我们直接放到IDA里面分析，但是发现main函数，既然没有main函数那么我们就看start函数</p></li></ul><img src="/2022/03/10/ni-xiang-zhi-lu-de-di-si-zhou/image7.jpg" class=""><ul><li><p>发现就两个函数有用，sub_4010F0和sub_401050</p></li><li><p>sub_4010F0,去掉输入字符中的’\n’和’\r’</p></li></ul><img src="/2022/03/10/ni-xiang-zhi-lu-de-di-si-zhou/image9.jpg" class=""><ul><li>sub_401050</li></ul><img src="/2022/03/10/ni-xiang-zhi-lu-de-di-si-zhou/image10.jpg" class=""><ul><li>代码的逻辑好理解，问题就是V4的第一个值，即sub_401000不知道看了网上的wp都是用OD动态分析，我目前还不会，先记录一下，等会了再来解决</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手过花指令2</title>
      <link href="/2022/03/05/shou-guo-hua-zhi-ling-2/"/>
      <url>/2022/03/05/shou-guo-hua-zhi-ling-2/</url>
      
        <content type="html"><![CDATA[<ul><li>本博客参考来源：<a href="https://blog.csdn.net/weixin_44352049/article/details/85850733">https://blog.csdn.net/weixin_44352049/article/details/85850733</a></li></ul><h2 id="花指令的干扰"><a href="#花指令的干扰" class="headerlink" title="花指令的干扰"></a>花指令的干扰</h2><ul><li>因为在花指令的干扰下，无法用OD、IDA之类的软件直接分析<br>（当然可以通过大神已经编写好的插件脱花指令，如果你强调这个没有去花插件快、便捷。那么恭喜你，可以直接关掉页面了，这篇不适合你，这只是为了一起分析、一起学习、一起进步，而不是教你如何使用去花插件。）<br>所以我们要手动分析，<br>但是问题来了，就算手动分析了一处，两处，三处，一个软件里花可能有上百出处，<br>就算全部分析完了，也需要一处处去掉<br>所以需要写一个脚本，帮助自己快速分析花指令。所以需要写一个脚本，帮助自己快速分析花指令。<br>那么如何让程序自动识别和去掉花指令呢</li></ul><h2 id="去除花指令"><a href="#去除花指令" class="headerlink" title="去除花指令"></a>去除花指令</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>花指令原理之前已经说过了，就是来回的跳转，然后插入一些垃圾机器码比如单独看起来无效的E8、EB、0等等垃圾数据，使反编译软件无法分析，那么就要分两步去除花指令了。<br>第一步识别哪些是有用的数据，哪些是垃圾数据。第二步：把垃圾数据用nop(0x90h)填充。</li></ul><h3 id="识别垃圾数据"><a href="#识别垃圾数据" class="headerlink" title="识别垃圾数据"></a>识别垃圾数据</h3> <img src="/2022/03/05/shou-guo-hua-zhi-ling-2/image1.jpg" class=""><ul><li>如图，是上次手动修改的内容，就是有花导致反汇编无法继续分析的一个地方，</li></ul> <img src="/2022/03/05/shou-guo-hua-zhi-ling-2/image2.jpg" class=""><ul><li>经过过程梳理（看蓝色箭头）发现其实中间所有的部分都可以nop掉，并不影响程序的运行，</li></ul> <img src="/2022/03/05/shou-guo-hua-zhi-ling-2/image3.jpg" class=""><ul><li>如图依次按D将其转换为数据同理，分析出需要nop掉的下面的部分<br>（有人会说灰色部分也是花对吧。但是这个不影响反编译，而且为了匹配更多的花，舍弃一句无关紧要的代码不去除也无伤大雅。当然也可以通过和我一起学习后，自己DIY，这个都好说）</li></ul> <img src="/2022/03/05/shou-guo-hua-zhi-ling-2/image4.jpg" class=""><img src="/2022/03/05/shou-guo-hua-zhi-ling-2/image5.jpg" class="">]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手过花指令1</title>
      <link href="/2022/03/05/shou-guo-hua-zhi-ling-1/"/>
      <url>/2022/03/05/shou-guo-hua-zhi-ling-1/</url>
      
        <content type="html"><![CDATA[<ul><li>本博客参考来源：<a href="https://blog.csdn.net/weixin_44352049/article/details/85567929">https://blog.csdn.net/weixin_44352049/article/details/85567929</a></li></ul><h2 id="侦壳"><a href="#侦壳" class="headerlink" title="侦壳"></a>侦壳</h2><img src="/2022/03/05/shou-guo-hua-zhi-ling-1/image1.jpg" class=""> <h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><h3 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h3><img src="/2022/03/05/shou-guo-hua-zhi-ling-1/image2.jpg" class=""> <ul><li>用IDA打开后，发现最底下是红色的，且有很多黑色部分（未知）还有大部分的data数据，而且没有发现已解锁的函数(蓝色部分)需要进行脱壳</li></ul><h2 id="IDA实现"><a href="#IDA实现" class="headerlink" title="IDA实现"></a>IDA实现</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><ul><li>图解部分（不知道应该怎么叫）最上面可以看到上面有个pushad</li></ul><img src="/2022/03/05/shou-guo-hua-zhi-ling-1/image3.jpg" class=""><ul><li>点击空格键，切换成流程图模式</li></ul><img src="/2022/03/05/shou-guo-hua-zhi-ling-1/image4.jpg" class=""><ul><li>图中的代码部分</li></ul><pre><code>start    endp    ;sp-analysis failed</code></pre><p>//分号后面的是注释，此处意为【分析失败】</p><pre><code>                ;sub_456189↓p</code></pre><p>//此处注释意为【分析交叉引用有冲突】<br>//一般是导航带上深红色区域</p><ul><li>定位到红色出错的CALL按D，转变为数据</li></ul><img src="/2022/03/05/shou-guo-hua-zhi-ling-1/image5.jpg" class=""><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>全部分析错误都没有了，开始人工分析</li></ul><img src="/2022/03/05/shou-guo-hua-zhi-ling-1/image6.jpg" class=""><img src="/2022/03/05/shou-guo-hua-zhi-ling-1/image7.jpg" class=""><ul><li>因为E8机器码在汇编中会被翻译为call，但是后面的EB OC 00 00会被翻译成call的地址，但是这个地址并不存在，因此会报错。那么就很清楚了，这里不是call而是jmp到一个地址光标定位到下一行EB，按C，将数据转换为代码</li></ul><img src="/2022/03/05/shou-guo-hua-zhi-ling-1/image8.jpg" class=""><ul><li>至此，一处花搞定。那什么叫做花指令呢，就是在本来正常的顺序下，让其不停跳转，中间一些永远不会执行到的地方，加上一些其他字符，使反编译器无法正常分析，就达到了在一定程度上保护程序的功效。这个截图上，除了这一处，还有一处，如下图</li></ul><img src="/2022/03/05/shou-guo-hua-zhi-ling-1/image9.jpg" class=""><ul><li>这个near ptr byte_4560FF也是不知其为何物。分析一下，发现这个一整段都是花，没有意义</li></ul><img src="/2022/03/05/shou-guo-hua-zhi-ling-1/image10.jpg" class=""><h2 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h2><ul><li>一堆花加在一起，是为花指令<br>这个例子中，有以下几种情形(分析出来类型，方便接下来用脚本去除所有的花指令)<br>本来想用Md的Flowchart流程图写一下大概流程的。。<br>试了几次，放弃了<br>反正asm汇编的代码也算是很好懂的。</li></ul><h3 id="情形一"><a href="#情形一" class="headerlink" title="情形一"></a>情形一</h3><pre><code>call label1    db 0E8hlabel2:    jmp label3    db 0    db 0    db 0E8h    db 0F6h    db 0FFh    db OFFh    db OFFhlabel1:     :call label2label3:    add esp,8</code></pre><h3 id="情形二"><a href="#情形二" class="headerlink" title="情形二"></a>情形二</h3><pre><code>jz label1    jnz label1    db 0EBh    db2label1:    jmp label2    db 81hlabel2:</code></pre><h3 id="情形三"><a href="#情形三" class="headerlink" title="情形三"></a>情形三</h3><pre><code>push eax    call label1    db 29h    db 5Ahlabel1:    POP eax    imul eax,3    call label2    db 29h    db5Ahlabel2:    add esp,4    pop eax</code></pre><h3 id="情形四"><a href="#情形四" class="headerlink" title="情形四"></a>情形四</h3><pre><code>jmp label1    db 68hlabel1:     jmp label2    db 0CDh,20hlabel2:    jmp label3    db 0E8hlabel3:</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向之路的第三周</title>
      <link href="/2022/03/03/ni-xiang-zhi-lu-de-di-san-zhou/"/>
      <url>/2022/03/03/ni-xiang-zhi-lu-de-di-san-zhou/</url>
      
        <content type="html"><![CDATA[<h2 id="Buuctf-easyre1"><a href="#Buuctf-easyre1" class="headerlink" title="Buuctf easyre1"></a>Buuctf easyre1</h2><ul><li>这是buuctf里的一道简单题目，<a href="https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]easyre">easyre1</a> ,主要就是脱壳然后放到ida里面反汇编一下就可以，关键代码如下</li></ul><img src="/2022/03/03/ni-xiang-zhi-lu-de-di-san-zhou/image1.jpg" class="">  <ul><li>所以解题代码如下</li></ul><pre><code>data = "}|{zyxwvutsrqponmlkjihgfedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)('&amp;%$# !\""s = "*F'\"N,\"(I?+@"flag =""for i in range(len(s)):    j = data.find(s[i])    flag += chr(j + 1 - i)print(flag)</code></pre><h2 id="Buuctf-Rome"><a href="#Buuctf-Rome" class="headerlink" title="Buuctf Rome"></a>Buuctf Rome</h2><ul><li>这是一道简单的加密题目，<a href="https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]rome">Rome</a>,查壳发现没有壳所以直接放到ida里面</li><li>关键代码如下，加密方式有点类似于凯撒加密，只不过对大小写字母分别移动，小写字母移动14位，大写字母移动18位</li></ul><img src="/2022/03/03/ni-xiang-zhi-lu-de-di-san-zhou/image2.jpg" class=""><ul><li>解题代码如下</li></ul><pre><code>flag=''v12='Qsw3sj_lz4_Ujw@l'for i in range(16):    for k in range(32,127):        z=k        if k&gt;64 and k&lt;=90:            k=(k-51)%26+65        if k&gt;96 and k&lt;=122:            k=(k-79)%26+97        if chr(k)==v12[i]:            flag+=chr(z)print(flag)</code></pre><h2 id="Buuctf-re"><a href="#Buuctf-re" class="headerlink" title="Buuctf re"></a>Buuctf re</h2><ul><li>这是buuctf里的一道简单题目，<a href="https://buuoj.cn/challenges#[GUET-CTF2019]re">re</a> ,主要就是虚拟机里面脱壳然后放到ida里面反汇编一下就可以，关键代码如下</li></ul><img src="/2022/03/03/ni-xiang-zhi-lu-de-di-san-zhou/image3.jpg" class=""><ul><li>解题代码如下</li></ul><pre><code>a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]a[0]=chr(166163712//1629056)a[1] = chr(731332800 // 6771600)a[2] = chr(357245568 // 3682944)a[3] = chr(1074393000 // 10431000)a[4] = chr(489211344 // 3977328)a[5] = chr(518971936 // 5138336)a[7] = chr(406741500 // 7532250)a[8] = chr(294236496 // 5551632)a[9] = chr(177305856 // 3409728)a[10] = chr(650683500 // 13013670)a[11] = chr(298351053 // 6088797)a[12] = chr(386348487 // 7884663)a[13] = chr(438258597 // 8944053)a[14] = chr(249527520 // 5198490)a[15] = chr(445362764 // 4544518)a[16] = chr(981182160 // 10115280)a[17] = chr(174988800 // 3645600)a[18] = chr(493042704 // 9667504)a[19] = chr(257493600 // 5364450)a[20] = chr(767478780 // 13464540)a[21] = chr(312840624 // 5488432)a[22] = chr(1404511500 // 14479500)a[23] = chr(316139670 // 6451830)a[24] = chr(619005024 // 6252576)a[25] = chr(372641472 // 7763364)a[26] = chr(373693320 // 7327320)a[27] = chr(498266640 // 8741520)a[28] = chr(452465676 // 8871876)a[29] = chr(208422720 // 4086720)a[30] = chr(515592000 // 9374400)a[31] = chr(719890500 // 5759124)for i in range(32):    print(a[i],end='')</code></pre><ul><li>得到 flag{e065421110ba03099a1c039337}，但是这不是最终的答案，因为仔细观察关键函数发现是没有a[6]的，而且还有一个细节就是a[16]和a[17]的顺序是颠倒的，需要仔细观察，至于a[6]这一位，反正也只能是0–9和a–z其中的一个，可以一个个的尝试进行爆破，最终得出正确答案为flag{e165421110ba03099a1c039337}</li></ul><h2 id="Buuctf-level"><a href="#Buuctf-level" class="headerlink" title="Buuctf level"></a>Buuctf level</h2><ul><li>这是buuctf里的一道巨简单题目，<a href="https://buuoj.cn/challenges#[WUSTCTF2020]level2">level2</a> ,主要就是虚拟机里面脱壳然后放到ida里面反汇编一下就可以看到答案，关键代码如下</li></ul><img src="/2022/03/03/ni-xiang-zhi-lu-de-di-san-zhou/image4.jpg" class=""><h2 id="Buuctf-Maze"><a href="#Buuctf-Maze" class="headerlink" title="Buuctf Maze"></a>Buuctf Maze</h2><ul><li>这是buuctf里的一道题目，<a href="https://buuoj.cn/challenges#[HDCTF2019]Maze">Maze</a> ,首先还是放到虚拟机里面upx -d “文件名”脱壳一下，然后放ida里面，这是会发现这是一个含有花指令的程序，没有main函数并且ida代码段里标注有红色</li></ul><img src="/2022/03/03/ni-xiang-zhi-lu-de-di-san-zhou/image5.jpg" class=""><ul><li>其中这里jnz跳转到了下一行代码，相当于没跳转，因为这一段代码即使不是jnz执行完了程序依旧会跳转到下一行代码，所以先用keypatch将jnz给nop掉</li></ul><img src="/2022/03/03/ni-xiang-zhi-lu-de-di-san-zhou/image6.jpg" class=""><ul><li>然后就是下面call跳转这一行，即ida代码段标注红色的部分,这是一个跳转指令，但是这个地址是错误的，调用了一个不是地址的地址，可以推断出这段代码添加了花指令，IDA分析失败了，而这段call 指令并不能像上面的jnz一样全部nop掉，因为nop掉了发现依然没法F5反汇编，所以我们选中0EC85D78Bh，按D将其转换为字节数据</li></ul><img src="/2022/03/03/ni-xiang-zhi-lu-de-di-san-zhou/image7.jpg" class=""><ul><li>而db 0E8h这条指令是添加的花指令，将其nop掉</li></ul><img src="/2022/03/03/ni-xiang-zhi-lu-de-di-san-zhou/image8.jpg" class=""><ul><li>此时你会发现关键代码的地址全部变为了红色，别急，鼠标选中关键代码区域，按P将其声明为函数，然后你就会发现出线了main函数，可以F5反汇编了！</li><li>最后就是常规的走迷宫，答案为flag{ssaaasaassdddw}</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花指令</title>
      <link href="/2022/02/03/hua-zhi-ling/"/>
      <url>/2022/02/03/hua-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>花指令是对抗反汇编的有效手段之一，正常代码添加了花指令之后，可以破坏静态反汇编的过程，使反汇编的结果出现错误。错误的反汇编结果会造成破解者的分析工作大量增加，进而使之不能理解程序的结构和算法，也就很难破解程序，从而达到病毒或软件保护的目的。其实质就是一串垃圾指令，它与程序本身的功能无关，并不影响程序本身的逻辑。在软件保护中，花指令被作为一种手段来增加静态分析的难度，花指令也可以被用在病毒或木马上，通过加入花指令改变程序的特征码，躲避杀软的扫描，从而达到免杀的目的，本文将介绍一些常见的花指令的形式，花指令一般被分为两类，被执行的和不会被执行的。花指令是企图隐藏掉不想被逆向工程的代码块 (或其它功能) 的一种方法, 在真实代码中插入一些垃圾代码的同时还保证原有程序的正确执行, 而程序无法很好地反编译, 难以理解程序内容, 达到混淆视听的效果.</li></ul><h2 id="花指令的分类"><a href="#花指令的分类" class="headerlink" title="花指令的分类"></a>花指令的分类</h2><h3 id="可执行式花指令"><a href="#可执行式花指令" class="headerlink" title="可执行式花指令"></a>可执行式花指令</h3><ul><li>可执行式花指令指的是能够正常运行的但又不改变原始程序逻辑性的一组无用指令。这类花指令有如下特点：①可以正常运行；②不改变任何寄存器的值；③反汇编器可以正确反汇编该指令。例如这样几组花指令就属于该类别：PUSHEAX＆POPEAX；NOP：INCEAX&amp;DECEAX等等。这种类别的花指令组合形式很多，常常用在病毒代码的变形引擎中，病毒在传播时通过变形引擎随机产生一组该类别花指令并插入到病毒正常代码中，可以改变病毒的特征码，从而起到变形的作用。</li></ul><h3 id="不可执行花指令"><a href="#不可执行花指令" class="headerlink" title="不可执行花指令"></a>不可执行花指令</h3><ul><li>不可执行花指令是指被插入到原始代码中但又不改变原始程序逻辑性的一组无用字节。这类花指令有如下特点：①不可以正常运行；②不改变任何寄存器的值；③反汇编器可能会错误反汇编这些字节。根据反汇编的工作原理，只有当花指令同正常指令的开始几个字节被反汇编器识别成一条指令时，才能有效破坏反汇编的结果。因此，插入的花指令应当是一些不完整的指令，被插入的不完整指令可以是随机选择的。正因为不可执行花指令有这些特点，该类花指令才能应用到软件保护中。Cullen等人指出为了能够有效“迷惑”静态反汇编工具，同时保证代码的正确运行，花指令必须满足两个基本特征，即：  1)垃圾数据必须是某个合法指令的一部分：  </li></ul><p>2)程序运行时，花指令必须位于实际不可执行的代码路径。</p><h2 id="线性扫描和行递归"><a href="#线性扫描和行递归" class="headerlink" title="线性扫描和行递归"></a>线性扫描和行递归</h2><ul><li>不可执行花指令的成功产生主要来自反汇编算法的缺陷，而当前反汇编算法主要分为两种，线性递归扫描和行递归扫描</li></ul><h3 id="线性扫描算法"><a href="#线性扫描算法" class="headerlink" title="线性扫描算法"></a>线性扫描算法</h3><ul><li>线性扫描算法p1从程序的入口点开始反汇编，然后对整个代码段进行扫描，反汇编扫描过程中所遇到的每条指令。线性扫描算法的缺点在于在冯诺依曼体系结构下，无法区分数据与代码，从而导致将代码段中嵌入的数据误解释为指令的操作码，以致最后得到错误的反汇编结果。</li></ul><h3 id="行递归算法"><a href="#行递归算法" class="headerlink" title="行递归算法"></a>行递归算法</h3><ul><li>相比线性扫描算法，行进递归算法通过程序的控制流来确定反汇编的下一条指令，遇到非控制转移指令时顺序进行反汇编，而遇到控制转移指令时则从转移地址处开始进行反汇编。行进递归算法的缺点在于准确确定间接转移目的地址的难度较大。</li></ul><h2 id="常见花指令"><a href="#常见花指令" class="headerlink" title="常见花指令"></a>常见花指令</h2><ul><li>jx + jnx </li></ul><img src="/2022/02/03/hua-zhi-ling/image1.jpg" class="">  <ul><li>call+pop/add esp/add [esp] + retn</li></ul><img src="/2022/02/03/hua-zhi-ling/image2.jpg" class=""><ul><li>stx/jx</li></ul><img src="/2022/02/03/hua-zhi-ling/image3.jpg" class="">]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向分析-XTEA加密</title>
      <link href="/2022/01/29/ni-xiang-fen-xi-xtea-jia-mi/"/>
      <url>/2022/01/29/ni-xiang-fen-xi-xtea-jia-mi/</url>
      
        <content type="html"><![CDATA[<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><img src="/2022/01/29/ni-xiang-fen-xi-xtea-jia-mi/image1.jpg" class="">  <h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) {      unsigned int i;      uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;      for (i=0; i &lt; num_rounds; i++) {          v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);          sum += delta;          v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);      }      v[0]=v0; v[1]=v1;  }     void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) {      unsigned int i;      uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;      for (i=0; i &lt; num_rounds; i++) {          v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);          sum -= delta;          v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);      }      v[0]=v0; v[1]=v1;  }     int main()  {      uint32_t v[2]={1,2};      uint32_t const k[4]={2,2,3,4};      unsigned int r=32;//num_rounds建议取值为32      // v为要加密的数据是两个32位无符号整数      // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位      printf("加密前原始数据：%u %u\n",v[0],v[1]);      encipher(r, v, k);      printf("加密后的数据：%u %u\n",v[0],v[1]);      decipher(r, v, k);      printf("解密后的数据：%u %u\n",v[0],v[1]);      return 0;  }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向分析-TEA加密</title>
      <link href="/2022/01/27/ni-xiang-fen-xi-tea-jia-mi/"/>
      <url>/2022/01/27/ni-xiang-fen-xi-tea-jia-mi/</url>
      
        <content type="html"><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><ul><li>TEA（Tiny Encryption Algorithm）是一种小型的对称加密解密算法，支持128位密码，与BlowFish一样TEA每次只能加密/解密8字节数据。TEA特点是速度快、效率高，实现也非常简单，用C语言实现TEA加密/解密算法只需26行代码。由于针对TEA的攻击不断出现，所以TEA也发展出几个版本，分别是XTEA、Block TEA和XXTEA。<br>TEA加密和解密时都使用一个常量值，这个常量值为0x9e377b9，这个值是近似黄金分割率，注意，有些编程人员为了避免在程序中直接出现”mov 变量，0x9e377b9”，以免被破解者直接搜索0x9e377b9这个常数得知使用TEA算法，所以有时会使用”sub 变量，0x61C88647”代替”mov 变量，0x9e377b9”，0x61C88647=－(0x9e377b9)。</li></ul><h2 id="主要代码部分"><a href="#主要代码部分" class="headerlink" title="主要代码部分"></a>主要代码部分</h2><h3 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h3><pre><code>void encrypt (uint32_t* v, uint32_t* k) {      uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */      uint32_t delta=0x9e3779b9;                     /* a key schedule constant */      uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */      for (i=0; i &lt; 32; i++) {                       /* basic cycle start */          sum += delta;          v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);          v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);      }                                              /* end cycle */      v[0]=v0; v[1]=v1;  }</code></pre><h3 id="解密函数"><a href="#解密函数" class="headerlink" title="解密函数"></a>解密函数</h3><pre><code>  void decrypt (uint32_t* v, uint32_t* k) {      uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */      uint32_t delta=0x9e3779b9;                     /* a key schedule constant */      uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */      for (i=0; i&lt;32; i++) {                         /* basic cycle start */          v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);          v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);          sum -= delta;      }                                              /* end cycle */      v[0]=v0; v[1]=v1;  }     int main()  {      uint32_t v[2]={1,2},k[4]={2,2,3,4};      // v为要加密的数据是两个32位无符号整数      // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位      printf("加密前原始数据：%u %u\n",v[0],v[1]);      encrypt(v, k);      printf("加密后的数据：%u %u\n",v[0],v[1]);      decrypt(v, k);      printf("解密后的数据：%u %u\n",v[0],v[1]);      return 0;  }  </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向之路的第二周</title>
      <link href="/2022/01/24/ni-xiang-zhi-lu-de-di-er-zhou/"/>
      <url>/2022/01/24/ni-xiang-zhi-lu-de-di-er-zhou/</url>
      
        <content type="html"><![CDATA[<h2 id="Buuctf-login"><a href="#Buuctf-login" class="headerlink" title="Buuctf login"></a>Buuctf login</h2><ul><li><p>这是buuctf里的一道简单题目，<a href="https://buuoj.cn/challenges#[FlareOn4]login">login</a> ,这道题主要就是考察对js代码的阅读能力</p><img src="/2022/01/24/ni-xiang-zhi-lu-de-di-er-zhou/image1.jpg" class="">  </li><li><p>解题关键就是这一行代码，其中我们需要知道JavaScript中的几条语法  </p></li></ul><pre><code>flag.replace(a,b),将flag中的字符a替换成b  String.fromCharCode(a)返回ASCII码a对应的字符  c.charCodeAt(0)返回字符c对应的ASCII码</code></pre><ul><li><p>所以这一道题就是你输入一串flag，对flag进行加密((c &lt;= “Z” ? 90 : 122) &gt;= (c = c.charCodeAt(0) + 13) ? c : c - 26);})之后变成了<a href="mailto:PyvragFvqrYbtvafNerRnfl@syner-ba.pbz">PyvragFvqrYbtvafNerRnfl@syner-ba.pbz</a>，这段加密的意思就是对a–z和A–Z的字母循环向后移13位，即a变成n,A变成M，Z变成M，其实理解了上面说的三条语法这个加密就不难理解了</p></li><li><p>解密代码如下</p></li></ul><pre><code>rotFlag = "PyvragFvqrYbtvafNerRnfl@syner-ba.pbz"flag = ""for i in rotFlag:    if 65 &lt;= ord(i) &lt;= 77 :        flag += chr(ord(i) + 13)    elif 78 &lt;= ord(i) &lt;= 90 :        flag += chr(ord(i) - 13)    elif 97 &lt;= ord(i) &lt;= 109 :        flag += chr(ord(i) + 13 )    elif 110 &lt;= ord(i) &lt;= 122:        flag += chr(ord(i) - 13 )    else:        flag += i print("flag{"+flag+"}")</code></pre><h2 id="Buuctf-findit"><a href="#Buuctf-findit" class="headerlink" title="Buuctf findit"></a>Buuctf findit</h2><ul><li>这道题的解题方法和 <a href="https://buuoj.cn/challenges#%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96">buuctf 刮开有奖</a> 有点类似，都是转换后的代码转移到自己的编译器里面执行，附件是apk文件，所以用jeb打开，找到对你输入进行验证的语句<br><img src="https://s2.loli.net/2021/12/03/2ynTkYoAZKh5bdI.png"></li></ul><h2 id="Buuctf-简单注册机"><a href="#Buuctf-简单注册机" class="headerlink" title="Buuctf 简单注册机"></a>Buuctf 简单注册机</h2><ul><li>用jeb打开转换成java代码然后把生成flag的语句放到C++/C编译器里面跑一下就行，目前为止最简单的一道题</li></ul><pre><code>char v5[] = "dd2940c04462b4dd7c450528835cca15";    v5[2] = ((char)(v5[2] + v5[3] - 50));    v5[4] = ((char)(v5[2] + v5[5] - 48));    v5[30] = ((char)(v5[31] + v5[9] - 48));    v5[14] = ((char)(v5[27] + v5[28] - 97));    int v4;    for(v4 = 0; v4 &lt; 16; ++v4)    {        char v0 = v5[31 - v4];        v5[31 - v4] = v5[v4];        v5[v4] = v0;    }    cout &lt;&lt; "flag{" &lt;&lt; v5 &lt;&lt; "}" ;</code></pre><h2 id="Buuctf-pyre"><a href="#Buuctf-pyre" class="headerlink" title="Buuctf pyre"></a>Buuctf pyre</h2><ul><li>直接在在线网站 <a href="http://tool.lu/pyc">在线工具</a> 上将pyc文件编译成py文件，然后写脚本结题即可<pre><code>code = [  '\x1f',   '\x12',  '\x1d',  '(',  '0',  '4',  '\x01',  '\x06',  '\x14',  '4',  ',',  '\x1b',  'U',  '?',  'o',  '6',  '*',  ':',  '\x01',  'D',  ';',  '%',  '\x13']for i in range(len(code)-2,-1,-1):   code[i] = chr(ord(code[i]) ^ ord(code[i+1]))flag = ""for i in range(len(code)):  flag += chr( (ord(code[i]) -i) % 128 )print(flag)</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向分析-Base64</title>
      <link href="/2021/12/28/ni-xiang-fen-xi-base64/"/>
      <url>/2021/12/28/ni-xiang-fen-xi-base64/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> 关于Base64的原理和加解密网上多的是，想要加解密一段字符串也可以到在线网站上去找，<a href="http://tool.chinaz.com/tools/base64.aspx">Base64</a> 就是其中一个，不过Base64解密工具在解密Base64时默认的标准串都是ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/，所以本偏博客的目的就是分享一个脚本，当标准串改变时能够根据所给的标准串进行编码和解码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>#coding:utf-8import reimport base64import stringimport randomdef base64_encode(s, dictionary):   r = ""   p = ""   c = len(s) % 3   if (c &gt; 0):       for i in range(c, 3):           p += '='           s += "\0"   for c in range(0, len(s), 3):       n = (ord(s[c]) &lt;&lt; 16) + (ord(s[c+1]) &lt;&lt; 8) + (ord(s[c+2]))       n = [(n &gt;&gt; 18) &amp; 0x3F, (n &gt;&gt; 12) &amp; 0x3F, (n &gt;&gt; 6) &amp; 0x3F, n &amp; 0x3F]       r += dictionary[n[0]] + dictionary[n[1]] + dictionary[n[2]] + dictionary[n[3]]   return r[0:len(r) - len(p)]  + pdef base64_decode(s, dictionary):   base64inv = {}   for i in range(len(dictionary)):       base64inv[dictionary[i]] = i   s = s.replace("\n", "")   if not re.match(r"^([{alphabet}]{{4}})*([{alphabet}]{{3}}=|[{alphabet}]{{2}}==)?$".format(alphabet = dictionary), s):       raise ValueError("Invalid input: {}".format(s))   if len(s) == 0:       return ""   p = "" if (s[-1] != "=") else "AA" if (len(s) &gt; 1 and s[-2] == "=") else "A"   r = ""   s = s[0:len(s) - len(p)] + p   for c in range(0, len(s), 4):       n = (base64inv[s[c]] &lt;&lt; 18) + (base64inv[s[c+1]] &lt;&lt; 12) + (base64inv[s[c+2]] &lt;&lt; 6) + base64inv[s[c+3]]       r += chr((n &gt;&gt; 16) &amp; 255) + chr((n &gt;&gt; 8) &amp; 255) + chr(n &amp; 255)   return r[0:len(r) - len(p)]def test_base64():   dictionary = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"   def random_string(length):       return ''.join(random.choice(string.ascii_letters) for m in range(length))   for i in range(100):       s = random_string(i)       encoded = base64_encode(s, dictionary)       assert(encoded == base64.b64encode(s))       assert(s == base64_decode(encoded, dictionary))if __name__ == "__main__":  dictionary =  "加解密的base64标准串"    //根据不同题目自行修改Base64的标准串  print(base64_decode("需要解密的内容", dictionary))    print(base64_encode("需要加密的内容",dictionary))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓逆向破解--欢乐切水果大作战</title>
      <link href="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/"/>
      <url>/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-Killer软件配置"><a href="#Android-Killer软件配置" class="headerlink" title="Android Killer软件配置"></a>Android Killer软件配置</h2><ul><li>配置Java SDK环境<br>注意安装路径是你电脑上jdk根目录下的bin文件夹<img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image1.jpg" class=""></li><li>更新ApkTool<br>到ApkTool官方网站 <a href="https://ibotpeaches.github.io/Apktool/">ApkTool</a> 上下载最新版本的ApkTool,把下载好的jar文件放到AndroidKiller根目录下的bin\apktool\apktool里面，然后返回到上一级目录bin\apktool去修改apktool.bat和apktool.ini两个文件的内容，把使用的ApkTool修改成刚刚下载的那个<img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image2.jpg" class=""></li></ul><h2 id="欢乐切水果大乱斗"><a href="#欢乐切水果大乱斗" class="headerlink" title="欢乐切水果大乱斗"></a>欢乐切水果大乱斗</h2><ul><li><p>我们破解修改这个软件的目的是修改apk文件里面和支付程序，让我们不充钱也可以购买装备，先在模拟器里面打开游戏点击充值看一下有什么提示，切记不要真充钱了</p><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image3.jpg" class=""></li><li><p>提示信息支付失败，所以我们用 Android Killer 打开apk文件，在工程搜索，搜索字符里面输入字符串’失败’，然后文本转unicode再搜索，不然直接以文本’失败’搜索的话找不到我们需要的函数  </p><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image4.jpg" class=""></li><li><p>在上图中发现定义的三个跟支付有关的函数 payResultCancel,payResultSuccess,payResultFalse,所以软件应该是根据你支付的情况分别跳转到这三个相应的函数，那就好办了，如果我们让程序无论用户支付成功还是失败都跳转到 payResultSuccess 函数里面岂不美哉  </p></li><li><p>在图中工程管理器所示的路径下找到 MiGuSdkPay$1.smali ,发现里面正好有根据我们的支付行为选择跳转到 payResultCancel,payResultSuccess,payResultFalse 三个相应函数里面的关键代码。至于是怎么发现关键函数在 MiGuSdkPay$1.smali 里面的，emmmm我一个一个点开看的…..  </p><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image5.jpg" class=""></li><li><p>我们把根据相应支付行为跳转到的函数都改成 payResultSuccess 函数  </p><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image6.jpg" class=""></li><li><p>然后下一步我们还可以在搜索框搜索游戏的名字 ‘欢乐切水果大作战’，然后把它修改为我们自己想定义的名字。然后点击主菜单栏Android 下的编译进行生成。- 当然你也可以修改其他的东西，包括图片音乐啥的，但是我现在技术还连入门都算不上，所以暂时还不会，等日后会的再来完善，现在我们用模拟器看看修改后的效果。</p></li><li><p>白嫖成功！逆向果然刑！！！</p></li></ul><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image7.jpg" class=""><p>-</p>]]></content>
      
      
      
        <tags>
            
            <tag> Game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向之路的第一周</title>
      <link href="/2021/11/29/ni-xiang-zhi-lu-de-di-yi-zhou/"/>
      <url>/2021/11/29/ni-xiang-zhi-lu-de-di-yi-zhou/</url>
      
        <content type="html"><![CDATA[<h2 id="修改汇编代码"><a href="#修改汇编代码" class="headerlink" title="修改汇编代码"></a>修改汇编代码</h2><h3 id="直接跳转到生成flag的函数"><a href="#直接跳转到生成flag的函数" class="headerlink" title="直接跳转到生成flag的函数"></a>直接跳转到生成flag的函数</h3><ul><li>题目是来自 <a href="https://ctf.bugku.com/">Bugku</a> 里面的一道入门题 <a href="https://ctf.bugku.com/challenges/detail/id/116.html">游戏过关</a>  查壳反汇编不用说了，这道题是让你输入一些数字让程序最终执行到输出flag的函数<br>如果你游戏水平够高你也可以直接通过玩游戏来获取flag，不然的话还是修改汇编代码来的直接，找到main函数，在几个call  sub_45A7BE指令里面随便选一个修改为call  sub_45E940，保存运行即可，当然了前提是你能找到main函数和打印的flag的函数，再次运行exe文件即可得到flag</li></ul><p><img src="http://pic.yupoo.com/wfscjz/1639f889/big.png"></p><h2 id="安卓逆向"><a href="#安卓逆向" class="headerlink" title="安卓逆向"></a>安卓逆向</h2><h3 id="记一下自己逆向路上遇到的第一个安卓逆向题"><a href="#记一下自己逆向路上遇到的第一个安卓逆向题" class="headerlink" title="记一下自己逆向路上遇到的第一个安卓逆向题"></a>记一下自己逆向路上遇到的第一个安卓逆向题</h3><ul><li>题目时来自 <a href="https://ctf.bugku.com/">Bugku</a> 里的一入门题 <a href="https://ctf.bugku.com/challenges/detail/id/136.html">signin</a>,先在模拟器里面运行一下看看效果<br><img src="http://pic.yupoo.com/wfscjz/1ec16f3e/big.png"><br>猜测是一个输入字符然后验证的程序，我们用jeb打开apk文件，找到main函数按Q反编译成java代码<br><img src="http://pic.yupoo.com/wfscjz/eb4bfac8/big.png"><br>main函数里面的getFlag()函数是返回地址为2131427360处的字符串，然后该字符串在checkPassword函数中先被reverse翻转一下，然后base64解码，解码后的内容即为我们想要找的flag，所以问题变成了我们只需要找到地址为2131427360处的字符串即可<br>在apk文件的R类中可以找到地址为2131427360处的字符串命名为”toString”,在string类中，但是我在jeb里面没找到res/values文件夹，所以在百度搜索之后用jadx打开apk文件找到res/values/strings.xml<br><img src="http://pic.yupoo.com/wfscjz/94e4b629/big.png"></li><li>成功找到了字符串，所以后续我们写脚本跑一下即可<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">import</span> base64a <span class="token operator">=</span> <span class="token string">"991YiZWOz81ZhFjZfJXdwk3X1k2XzIXZIt3ZhxmZ"</span>a <span class="token operator">=</span> a<span class="token punctuation">[</span>::-1<span class="token punctuation">]</span>print<span class="token punctuation">(</span>base64.b64decode<span class="token punctuation">(</span>a<span class="token punctuation">))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Buuctf-Reverse3"><a href="#Buuctf-Reverse3" class="headerlink" title="Buuctf Reverse3"></a>Buuctf Reverse3</h2><ul><li><p>查壳扔进IDA反汇编如下<br><img src="https://i.loli.net/2021/12/01/EzD1lFLBG296OIf.png"></p></li><li><p>所以我们反过来求解即可，脚本如下</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">import</span> base64a <span class="token operator">=</span> <span class="token string">"e3nifIH9b_C@n@dH"</span>flag <span class="token operator">=</span> <span class="token string">""</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>a<span class="token punctuation">))</span>:  flag +<span class="token operator">=</span> chr<span class="token punctuation">(</span>ord<span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> - i<span class="token punctuation">)</span>print<span class="token punctuation">(</span>base64.b64decode<span class="token punctuation">(</span>flag<span class="token punctuation">))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Buuctf-不一样的flag"><a href="#Buuctf-不一样的flag" class="headerlink" title="Buuctf 不一样的flag"></a>Buuctf 不一样的flag</h2><ul><li>查壳，反汇编然后走迷宫<br><img src="https://i.loli.net/2021/12/01/i9azrYMSbB2FQxE.png"></li></ul><h2 id="Buuctf-simplere"><a href="#Buuctf-simplere" class="headerlink" title="Buuctf simplere"></a>Buuctf simplere</h2><ul><li>个人感觉这道题主要考察的是大端存储和小端存储，这个如果不知道的话那么这道肯定做不出来 <a href="https://baijiahao.baidu.com/s?id=1609459208102387514">计算机中数据存储方式</a><br>查壳，拖进IDA反汇编，找到Decry()函数<br><img src="https://i.loli.net/2021/12/02/IqpsuYS3KBOVCfv.png"><br>前面的部分主要是生成text和key字符串的，下面是验证输入的过程，所以我们可以写代码反推出flag<br><img src="https://i.loli.net/2021/12/02/xdyrqEYutk6QVHX.png">  </li><li>但是由于源程序代码中还有模26的操作，但我目前没想到更好的办法，所以只能让i从0到4开始爆破，i大于4时范围超了肯定不正确<pre class="line-numbers language-bash"><code class="language-bash">char text<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"killshadow"</span><span class="token punctuation">;</span>  char key<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"adsfkndcls"</span><span class="token punctuation">;</span>  char V1<span class="token punctuation">;</span>  char flag<span class="token punctuation">[</span>10<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  int V3 <span class="token operator">=</span> 10<span class="token punctuation">;</span>  for<span class="token punctuation">(</span> int i<span class="token operator">=</span>0<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>4<span class="token punctuation">;</span>i++<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      for<span class="token punctuation">(</span> int j<span class="token operator">=</span>0<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>10<span class="token punctuation">;</span>j++<span class="token punctuation">)</span>      <span class="token punctuation">{</span>          V1 <span class="token operator">=</span> text<span class="token punctuation">[</span>j<span class="token punctuation">]</span> - 97  + i * 26 + key<span class="token punctuation">[</span>V3++%10<span class="token punctuation">]</span> - 58<span class="token punctuation">;</span>          if<span class="token punctuation">(</span> V1 <span class="token operator">&lt;</span> 90 <span class="token operator">&amp;&amp;</span> V1 <span class="token operator">></span> 65 <span class="token punctuation">)</span>              flag<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> V1<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  cout <span class="token operator">&lt;&lt;</span> flag <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Buuctf-Java逆向解密"><a href="#Buuctf-Java逆向解密" class="headerlink" title="Buuctf Java逆向解密"></a>Buuctf Java逆向解密</h2><ul><li>附件是.class文件，所以直接用jd-gui打开<br><img src="https://i.loli.net/2021/12/02/djfN4bxquEDrHYv.png"></li><li>只是在数后面加上异或的值，java脚本如下</li></ul><pre><code>public static void main(String[] args) {        // TODO Auto-generated method stub        String flag = "" ;        int[] KEY = { 180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65 };        for (int j = 0; j &lt; KEY.length; j++) {          flag += (char)(KEY[j] - '@' ^ 0x20);        }        System.out.print(flag);    }</code></pre><h2 id="Buuctf-刮开有奖"><a href="#Buuctf-刮开有奖" class="headerlink" title="Buuctf 刮开有奖"></a>Buuctf 刮开有奖</h2><ul><li><p>一道输入flag然后对你的输入进行验证的题目，查壳，反汇编，找到关键的函数<br><img src="https://i.loli.net/2021/12/03/FbHoKOafIND7EWX.png"></p></li><li><p>在把sub_4010F0()中的代码转移到编译器里面自己执行时需要修改一些内容，首先(_DWORD <em>)要去除，然后就是</em>( i * 4 + a1)，点击v7,v8等等会发现它们的地址都是相差4，当然这是因为是32位程序导致的，如果是64位程序相差就位8.所以当i等于1时*(1 * 4 + a1) 对应的就是v8的值，是不是很像C++数组里面的 *（a + i ) ,所以在把代码转移到自己的编译器上时，你可以做如下修改 ：</p><p>1 将v7[0] 到 v16 的值用一个长度为11的数组表示</p><p>2 删去(_DWORD *) 和所有的 4 *</p></li><li><p>最后代码如下，跑一下就能出结果</p></li></ul><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int __cdecl sub_4010F0(int *a1, int a2, int a3){  int result; // eax  int i; // esi  int v5; // ecx  int v6; // edx  result = a3;  for ( i = a2; i &lt;= a3; a2 = i )  {    v5 =  i;    v6 = a1[i];    if ( a2 &lt; result &amp;&amp; i &lt; result )    {      do      {        if ( v6 &gt; a1[result] )        {          if ( i &gt;= result )            break;          ++i;          a1[v5] = a1[result];          if ( i &gt;= result )            break;          while ( a1[i] &lt;= v6 )          {            if ( ++i &gt;= result )              goto LABEL_13;          }          if ( i &gt;= result )            break;          v5 =  i;          a1[result] = a1[i];        }        --result;      }      while ( i &lt; result );    }LABEL_13:    a1[result] = v6;    sub_4010F0(a1, a2, i - 1);    result = a3;    ++i;  }  return result;}int main(){    char flag[] = "WP1jMp" ; // v4 和 v5 base64解码    int arry[11] = {90,74,83,69,67,97,78,72,51,110,103};    sub_4010F0(arry,0,10) ;    cout &lt;&lt; "flag{" &lt;&lt; (char)(arry[0] + 34) &lt;&lt; char(arry[4]) &lt;&lt; flag &lt;&lt; "}" ;    return 0;}</code></pre><h2 id="Buuctf-luck-guy"><a href="#Buuctf-luck-guy" class="headerlink" title="Buuctf luck_guy"></a>Buuctf luck_guy</h2><ul><li>查壳，反汇编找到关键函数getflag()<br><img src="https://i.loli.net/2021/12/03/QbDg6eIymoC8XEw.png"></li><li>写代码跑一下即可,提交时把GXY换成flag即可</li></ul><pre><code>s = "icug`of"flag = "GXY{do_not_"for i in range(len(s)):    if i % 2 == 1:       flag += chr(ord(s[i]) - 2 )    else:       flag += chr(ord(s[i]) - 1 )print(flag)</code></pre><h2 id="Buuctf-JustRe"><a href="#Buuctf-JustRe" class="headerlink" title="Buuctf JustRe"></a>Buuctf JustRe</h2><ul><li>直接使用keypatch插件修改汇编代码让点击一次即可即可，当然你点击19999次也能出答案<br><img src="https://i.loli.net/2021/12/03/hSmrnbUAHuTtXCK.png"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向分析--对称加密RC4</title>
      <link href="/2021/01/17/ni-xiang-fen-xi-dui-cheng-jia-mi-rc4/"/>
      <url>/2021/01/17/ni-xiang-fen-xi-dui-cheng-jia-mi-rc4/</url>
      
        <content type="html"><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><ul><li>RC4是一种对称的流加密算法，它的密钥长度可变，通过随机数生成的核心与异或运算完成对于数据流的加密。相对于AES，DES对于固定长度数据块加密，RC4输入的plaintext为任意的。RC4的特点是运算速度快，密钥长度为1–256BYTE可变。<br>RC4的核心可以分为对密钥空间s的初始化与密文的交换。</li></ul><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ul><li>初始化S盒并用秘钥打乱S盒</li></ul><pre><code>void rc4_init(unsigned char*s,unsigned char*key,unsigned long len)//s最开始是传入的长度为256的char型空数组，用来存放初始化后的s//key是定义的秘钥  //最后一个len是密钥的长度{   int i=0;   int j=0;   unsigned char k[256]={};   unsigned char temp = 0;   for(i=0;i&lt;256;i++)    {       s[i]=i;         //0-255赋给s       k[i]=key[i%len];   //将k重新计算    }   for(i=0;i&lt;256;i++)   {      j=(j+s[i]+k[i])%256;    //给j赋      temp=s[i];      s[i]=s[j];      s[j]=temp;    //s[i]和s[j]交换   }}</code></pre><ul><li>加解密部分，因为是对称加密算法，所以既可加密也可解密</li></ul><pre><code>void rc4_crypt(unsigned char*s,unsigned char*data,unsigned long len)//s是上面初始化之后的，data是我们要加密的数据，len是data的长度{    int i=0,j=0,t=0;    unsigned long k=0;    unsigned char temp;    for(k=0;k&lt;len;k++)    {        i=(i+1)%256;            //固定方式        j=(j+s[i])%256;          //固定方式        temp=s[i];        s[i]=s[j];        s[j]=temp;             //s[i]和s[j]交换        t=(s[i]+s[j])%256;      //固定方式        data[k]^=s[t];          //异或运算，即加解密    }}</code></pre><ul><li>main函数</li></ul><pre><code>int main(){    unsigned char s[256] = {0};    unsigned char s2[256] = {0};    char key[256] = {"iloveyou"};    char data[512] = {"U2FsdGVkX1+WuEwk2Obam1iZnSWRLi8nKs0="};    unsigned long len = strlen(data);    rc4_init(s,(unsigned char*)key,strlen(key));    rc4_crypt(s,(unsigned char*)data,len);    cout &lt;&lt; data;    return 0;}</code></pre><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>介绍了这么多，主要是为了熟悉RC4加密的原理，但是真正在做题的时候还是直接去在线网站上解密RC4比较方便，除此之外，因为在逆向题目中RC4加密往往是调用某个函数来实现的，我们可以直接将这个函数复制到我们自己的编译器上跑一遍也能得出结果</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse Crypto </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
