<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>花指令</title>
      <link href="/2022/02/03/hua-zhi-ling/"/>
      <url>/2022/02/03/hua-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>花指令是对抗反汇编的有效手段之一，正常代码添加了花指令之后，可以破坏静态反汇编的过程，使反汇编的结果出现错误。错误的反汇编结果会造成破解者的分析工作大量增加，进而使之不能理解程序的结构和算法，也就很难破解程序，从而达到病毒或软件保护的目的。其实质就是一串垃圾指令，它与程序本身的功能无关，并不影响程序本身的逻辑。在软件保护中，花指令被作为一种手段来增加静态分析的难度，花指令也可以被用在病毒或木马上，通过加入花指令改变程序的特征码，躲避杀软的扫描，从而达到免杀的目的，本文将介绍一些常见的花指令的形式，花指令一般被分为两类，被执行的和不会被执行的。花指令是企图隐藏掉不想被逆向工程的代码块 (或其它功能) 的一种方法, 在真实代码中插入一些垃圾代码的同时还保证原有程序的正确执行, 而程序无法很好地反编译, 难以理解程序内容, 达到混淆视听的效果.</li></ul><h2 id="花指令的分类"><a href="#花指令的分类" class="headerlink" title="花指令的分类"></a>花指令的分类</h2><h3 id="可执行式花指令"><a href="#可执行式花指令" class="headerlink" title="可执行式花指令"></a>可执行式花指令</h3><ul><li>可执行式花指令指的是能够正常运行的但又不改变原始程序逻辑性的一组无用指令。这类花指令有如下特点：①可以正常运行；②不改变任何寄存器的值；③反汇编器可以正确反汇编该指令。例如这样几组花指令就属于该类别：PUSHEAX＆POPEAX；NOP：INCEAX&amp;DECEAX等等。这种类别的花指令组合形式很多，常常用在病毒代码的变形引擎中，病毒在传播时通过变形引擎随机产生一组该类别花指令并插入到病毒正常代码中，可以改变病毒的特征码，从而起到变形的作用。</li></ul><h3 id="不可执行花指令"><a href="#不可执行花指令" class="headerlink" title="不可执行花指令"></a>不可执行花指令</h3><ul><li>不可执行花指令是指被插入到原始代码中但又不改变原始程序逻辑性的一组无用字节。这类花指令有如下特点：①不可以正常运行；②不改变任何寄存器的值；③反汇编器可能会错误反汇编这些字节。根据反汇编的工作原理，只有当花指令同正常指令的开始几个字节被反汇编器识别成一条指令时，才能有效破坏反汇编的结果。因此，插入的花指令应当是一些不完整的指令，被插入的不完整指令可以是随机选择的。正因为不可执行花指令有这些特点，该类花指令才能应用到软件保护中。Cullen等人指出为了能够有效“迷惑”静态反汇编工具，同时保证代码的正确运行，花指令必须满足两个基本特征，即：  1)垃圾数据必须是某个合法指令的一部分：  </li></ul><p>2)程序运行时，花指令必须位于实际不可执行的代码路径。</p><h2 id="线性扫描和行递归"><a href="#线性扫描和行递归" class="headerlink" title="线性扫描和行递归"></a>线性扫描和行递归</h2><ul><li>不可执行花指令的成功产生主要来自反汇编算法的缺陷，而当前反汇编算法主要分为两种，线性递归扫描和行递归扫描</li></ul><h3 id="线性扫描算法"><a href="#线性扫描算法" class="headerlink" title="线性扫描算法"></a>线性扫描算法</h3><ul><li>线性扫描算法p1从程序的入口点开始反汇编，然后对整个代码段进行扫描，反汇编扫描过程中所遇到的每条指令。线性扫描算法的缺点在于在冯诺依曼体系结构下，无法区分数据与代码，从而导致将代码段中嵌入的数据误解释为指令的操作码，以致最后得到错误的反汇编结果。</li></ul><h3 id="行递归算法"><a href="#行递归算法" class="headerlink" title="行递归算法"></a>行递归算法</h3><ul><li>相比线性扫描算法，行进递归算法通过程序的控制流来确定反汇编的下一条指令，遇到非控制转移指令时顺序进行反汇编，而遇到控制转移指令时则从转移地址处开始进行反汇编。行进递归算法的缺点在于准确确定间接转移目的地址的难度较大。</li></ul><h2 id="常见花指令"><a href="#常见花指令" class="headerlink" title="常见花指令"></a>常见花指令</h2><ul><li>jx + jnx </li></ul><img src="/2022/02/03/hua-zhi-ling/image1.jpg" class="">  <ul><li>call+pop/add esp/add [esp] + retn</li></ul><img src="/2022/02/03/hua-zhi-ling/image2.jpg" class=""><ul><li>stx/jx</li></ul><img src="/2022/02/03/hua-zhi-ling/image3.jpg" class="">]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向分析-XTEA加密</title>
      <link href="/2022/01/29/ni-xiang-fen-xi-xtea-jia-mi/"/>
      <url>/2022/01/29/ni-xiang-fen-xi-xtea-jia-mi/</url>
      
        <content type="html"><![CDATA[<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><img src="/2022/01/29/ni-xiang-fen-xi-xtea-jia-mi/image1.jpg" class="">  <h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) {      unsigned int i;      uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9;      for (i=0; i &lt; num_rounds; i++) {          v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);          sum += delta;          v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);      }      v[0]=v0; v[1]=v1;  }     void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) {      unsigned int i;      uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds;      for (i=0; i &lt; num_rounds; i++) {          v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]);          sum -= delta;          v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);      }      v[0]=v0; v[1]=v1;  }     int main()  {      uint32_t v[2]={1,2};      uint32_t const k[4]={2,2,3,4};      unsigned int r=32;//num_rounds建议取值为32      // v为要加密的数据是两个32位无符号整数      // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位      printf("加密前原始数据：%u %u\n",v[0],v[1]);      encipher(r, v, k);      printf("加密后的数据：%u %u\n",v[0],v[1]);      decipher(r, v, k);      printf("解密后的数据：%u %u\n",v[0],v[1]);      return 0;  }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向分析-TEA加密</title>
      <link href="/2022/01/27/ni-xiang-fen-xi-tea-jia-mi/"/>
      <url>/2022/01/27/ni-xiang-fen-xi-tea-jia-mi/</url>
      
        <content type="html"><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><ul><li>TEA（Tiny Encryption Algorithm）是一种小型的对称加密解密算法，支持128位密码，与BlowFish一样TEA每次只能加密/解密8字节数据。TEA特点是速度快、效率高，实现也非常简单，用C语言实现TEA加密/解密算法只需26行代码。由于针对TEA的攻击不断出现，所以TEA也发展出几个版本，分别是XTEA、Block TEA和XXTEA。<br>TEA加密和解密时都使用一个常量值，这个常量值为0x9e377b9，这个值是近似黄金分割率，注意，有些编程人员为了避免在程序中直接出现”mov 变量，0x9e377b9”，以免被破解者直接搜索0x9e377b9这个常数得知使用TEA算法，所以有时会使用”sub 变量，0x61C88647”代替”mov 变量，0x9e377b9”，0x61C88647=－(0x9e377b9)。</li></ul><h2 id="主要代码部分"><a href="#主要代码部分" class="headerlink" title="主要代码部分"></a>主要代码部分</h2><h3 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h3><pre><code>void encrypt (uint32_t* v, uint32_t* k) {      uint32_t v0=v[0], v1=v[1], sum=0, i;           /* set up */      uint32_t delta=0x9e3779b9;                     /* a key schedule constant */      uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */      for (i=0; i &lt; 32; i++) {                       /* basic cycle start */          sum += delta;          v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);          v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);      }                                              /* end cycle */      v[0]=v0; v[1]=v1;  }</code></pre><h3 id="解密函数"><a href="#解密函数" class="headerlink" title="解密函数"></a>解密函数</h3><pre><code>  void decrypt (uint32_t* v, uint32_t* k) {      uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  /* set up */      uint32_t delta=0x9e3779b9;                     /* a key schedule constant */      uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3];   /* cache key */      for (i=0; i&lt;32; i++) {                         /* basic cycle start */          v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3);          v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1);          sum -= delta;      }                                              /* end cycle */      v[0]=v0; v[1]=v1;  }     int main()  {      uint32_t v[2]={1,2},k[4]={2,2,3,4};      // v为要加密的数据是两个32位无符号整数      // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位      printf("加密前原始数据：%u %u\n",v[0],v[1]);      encrypt(v, k);      printf("加密后的数据：%u %u\n",v[0],v[1]);      decrypt(v, k);      printf("解密后的数据：%u %u\n",v[0],v[1]);      return 0;  }  </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向之路的第二周</title>
      <link href="/2022/01/24/ni-xiang-zhi-lu-de-di-er-zhou/"/>
      <url>/2022/01/24/ni-xiang-zhi-lu-de-di-er-zhou/</url>
      
        <content type="html"><![CDATA[<h2 id="Buuctf-login"><a href="#Buuctf-login" class="headerlink" title="Buuctf login"></a>Buuctf login</h2><ul><li><p>这是buuctf里的一道简单题目，<a href="https://buuoj.cn/challenges#[FlareOn4]login">login</a> ,这道题主要就是考察对js代码的阅读能力</p><img src="/2022/01/24/ni-xiang-zhi-lu-de-di-er-zhou/image1.jpg" class="">  </li><li><p>解题关键就是这一行代码，其中我们需要知道JavaScript中的几条语法  </p></li></ul><pre><code>flag.replace(a,b),将flag中的字符a替换成b  String.fromCharCode(a)返回ASCII码a对应的字符  c.charCodeAt(0)返回字符c对应的ASCII码</code></pre><ul><li><p>所以这一道题就是你输入一串flag，对flag进行加密((c &lt;= “Z” ? 90 : 122) &gt;= (c = c.charCodeAt(0) + 13) ? c : c - 26);})之后变成了<a href="mailto:PyvragFvqrYbtvafNerRnfl@syner-ba.pbz">PyvragFvqrYbtvafNerRnfl@syner-ba.pbz</a>，这段加密的意思就是对a–z和A–Z的字母循环向后移13位，即a变成n,A变成M，Z变成M，其实理解了上面说的三条语法这个加密就不难理解了</p></li><li><p>解密代码如下</p></li></ul><pre><code>rotFlag = "PyvragFvqrYbtvafNerRnfl@syner-ba.pbz"flag = ""for i in rotFlag:    if 65 &lt;= ord(i) &lt;= 77 :        flag += chr(ord(i) + 13)    elif 78 &lt;= ord(i) &lt;= 90 :        flag += chr(ord(i) - 13)    elif 97 &lt;= ord(i) &lt;= 109 :        flag += chr(ord(i) + 13 )    elif 110 &lt;= ord(i) &lt;= 122:        flag += chr(ord(i) - 13 )    else:        flag += i print("flag{"+flag+"}")</code></pre><h2 id="Buuctf-findit"><a href="#Buuctf-findit" class="headerlink" title="Buuctf findit"></a>Buuctf findit</h2><ul><li>这道题的解题方法和 <a href="https://buuoj.cn/challenges#%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96">buuctf 刮开有奖</a> 有点类似，都是转换后的代码转移到自己的编译器里面执行，附件是apk文件，所以用jeb打开，找到对你输入进行验证的语句<br><img src="https://s2.loli.net/2021/12/03/2ynTkYoAZKh5bdI.png"></li></ul><h2 id="Buuctf-简单注册机"><a href="#Buuctf-简单注册机" class="headerlink" title="Buuctf 简单注册机"></a>Buuctf 简单注册机</h2><ul><li>用jeb打开转换成java代码然后把生成flag的语句放到C++/C编译器里面跑一下就行，目前为止最简单的一道题</li></ul><pre><code>char v5[] = "dd2940c04462b4dd7c450528835cca15";    v5[2] = ((char)(v5[2] + v5[3] - 50));    v5[4] = ((char)(v5[2] + v5[5] - 48));    v5[30] = ((char)(v5[31] + v5[9] - 48));    v5[14] = ((char)(v5[27] + v5[28] - 97));    int v4;    for(v4 = 0; v4 &lt; 16; ++v4)    {        char v0 = v5[31 - v4];        v5[31 - v4] = v5[v4];        v5[v4] = v0;    }    cout &lt;&lt; "flag{" &lt;&lt; v5 &lt;&lt; "}" ;</code></pre><h2 id="Buuctf-pyre"><a href="#Buuctf-pyre" class="headerlink" title="Buuctf pyre"></a>Buuctf pyre</h2><ul><li>直接在在线网站 <a href="http://tool.lu/pyc">在线工具</a> 上将pyc文件编译成py文件，然后写脚本结题即可<pre><code>code = [  '\x1f',   '\x12',  '\x1d',  '(',  '0',  '4',  '\x01',  '\x06',  '\x14',  '4',  ',',  '\x1b',  'U',  '?',  'o',  '6',  '*',  ':',  '\x01',  'D',  ';',  '%',  '\x13']for i in range(len(code)-2,-1,-1):   code[i] = chr(ord(code[i]) ^ ord(code[i+1]))flag = ""for i in range(len(code)):  flag += chr( (ord(code[i]) -i) % 128 )print(flag)</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向分析-Base64</title>
      <link href="/2021/12/28/ni-xiang-fen-xi-base64/"/>
      <url>/2021/12/28/ni-xiang-fen-xi-base64/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> 关于Base64的原理和加解密网上多的是，想要加解密一段字符串也可以到在线网站上去找，<a href="http://tool.chinaz.com/tools/base64.aspx">Base64</a> 就是其中一个，不过Base64解密工具在解密Base64时默认的标准串都是ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/，所以本偏博客的目的就是分享一个脚本，当标准串改变时能够根据所给的标准串进行编码和解码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>#coding:utf-8import reimport base64import stringimport randomdef base64_encode(s, dictionary):   r = ""   p = ""   c = len(s) % 3   if (c &gt; 0):       for i in range(c, 3):           p += '='           s += "\0"   for c in range(0, len(s), 3):       n = (ord(s[c]) &lt;&lt; 16) + (ord(s[c+1]) &lt;&lt; 8) + (ord(s[c+2]))       n = [(n &gt;&gt; 18) &amp; 0x3F, (n &gt;&gt; 12) &amp; 0x3F, (n &gt;&gt; 6) &amp; 0x3F, n &amp; 0x3F]       r += dictionary[n[0]] + dictionary[n[1]] + dictionary[n[2]] + dictionary[n[3]]   return r[0:len(r) - len(p)]  + pdef base64_decode(s, dictionary):   base64inv = {}   for i in range(len(dictionary)):       base64inv[dictionary[i]] = i   s = s.replace("\n", "")   if not re.match(r"^([{alphabet}]{{4}})*([{alphabet}]{{3}}=|[{alphabet}]{{2}}==)?$".format(alphabet = dictionary), s):       raise ValueError("Invalid input: {}".format(s))   if len(s) == 0:       return ""   p = "" if (s[-1] != "=") else "AA" if (len(s) &gt; 1 and s[-2] == "=") else "A"   r = ""   s = s[0:len(s) - len(p)] + p   for c in range(0, len(s), 4):       n = (base64inv[s[c]] &lt;&lt; 18) + (base64inv[s[c+1]] &lt;&lt; 12) + (base64inv[s[c+2]] &lt;&lt; 6) + base64inv[s[c+3]]       r += chr((n &gt;&gt; 16) &amp; 255) + chr((n &gt;&gt; 8) &amp; 255) + chr(n &amp; 255)   return r[0:len(r) - len(p)]def test_base64():   dictionary = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"   def random_string(length):       return ''.join(random.choice(string.ascii_letters) for m in range(length))   for i in range(100):       s = random_string(i)       encoded = base64_encode(s, dictionary)       assert(encoded == base64.b64encode(s))       assert(s == base64_decode(encoded, dictionary))if __name__ == "__main__":  dictionary =  "加解密的base64标准串"    //根据不同题目自行修改Base64的标准串  print(base64_decode("需要解密的内容", dictionary))    print(base64_encode("需要加密的内容",dictionary))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓逆向破解--欢乐切水果大作战</title>
      <link href="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/"/>
      <url>/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-Killer软件配置"><a href="#Android-Killer软件配置" class="headerlink" title="Android Killer软件配置"></a>Android Killer软件配置</h2><ul><li>配置Java SDK环境<br>注意安装路径是你电脑上jdk根目录下的bin文件夹<img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image1.jpg" class=""></li><li>更新ApkTool<br>到ApkTool官方网站 <a href="https://ibotpeaches.github.io/Apktool/">ApkTool</a> 上下载最新版本的ApkTool,把下载好的jar文件放到AndroidKiller根目录下的bin\apktool\apktool里面，然后返回到上一级目录bin\apktool去修改apktool.bat和apktool.ini两个文件的内容，把使用的ApkTool修改成刚刚下载的那个<img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image2.jpg" class=""></li></ul><h2 id="欢乐切水果大乱斗"><a href="#欢乐切水果大乱斗" class="headerlink" title="欢乐切水果大乱斗"></a>欢乐切水果大乱斗</h2><ul><li><p>我们破解修改这个软件的目的是修改apk文件里面和支付程序，让我们不充钱也可以购买装备，先在模拟器里面打开游戏点击充值看一下有什么提示，切记不要真充钱了</p><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image3.jpg" class=""></li><li><p>提示信息支付失败，所以我们用 Android Killer 打开apk文件，在工程搜索，搜索字符里面输入字符串’失败’，然后文本转unicode再搜索，不然直接以文本’失败’搜索的话找不到我们需要的函数  </p><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image4.jpg" class=""></li><li><p>在上图中发现定义的三个跟支付有关的函数 payResultCancel,payResultSuccess,payResultFalse,所以软件应该是根据你支付的情况分别跳转到这三个相应的函数，那就好办了，如果我们让程序无论用户支付成功还是失败都跳转到 payResultSuccess 函数里面岂不美哉  </p></li><li><p>在图中工程管理器所示的路径下找到 MiGuSdkPay$1.smali ,发现里面正好有根据我们的支付行为选择跳转到 payResultCancel,payResultSuccess,payResultFalse 三个相应函数里面的关键代码。至于是怎么发现关键函数在 MiGuSdkPay$1.smali 里面的，emmmm我一个一个点开看的…..  </p><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image5.jpg" class=""></li><li><p>我们把根据相应支付行为跳转到的函数都改成 payResultSuccess 函数  </p><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image6.jpg" class=""></li><li><p>然后下一步我们还可以在搜索框搜索游戏的名字 ‘欢乐切水果大作战’，然后把它修改为我们自己想定义的名字。然后点击主菜单栏Android 下的编译进行生成。- 当然你也可以修改其他的东西，包括图片音乐啥的，但是我现在技术还连入门都算不上，所以暂时还不会，等日后会的再来完善，现在我们用模拟器看看修改后的效果。</p></li><li><p>白嫖成功！逆向果然刑！！！</p></li></ul><img src="/2021/12/06/an-zhuo-ni-xiang-po-jie-huan-le-qie-shui-guo-da-zuo-zhan/image7.jpg" class=""><p>-</p>]]></content>
      
      
      
        <tags>
            
            <tag> Game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向之路的第一周</title>
      <link href="/2021/11/29/ni-xiang-zhi-lu-de-di-yi-zhou/"/>
      <url>/2021/11/29/ni-xiang-zhi-lu-de-di-yi-zhou/</url>
      
        <content type="html"><![CDATA[<h2 id="修改汇编代码"><a href="#修改汇编代码" class="headerlink" title="修改汇编代码"></a>修改汇编代码</h2><h3 id="直接跳转到生成flag的函数"><a href="#直接跳转到生成flag的函数" class="headerlink" title="直接跳转到生成flag的函数"></a>直接跳转到生成flag的函数</h3><ul><li>题目是来自 <a href="https://ctf.bugku.com/">Bugku</a> 里面的一道入门题 <a href="https://ctf.bugku.com/challenges/detail/id/116.html">游戏过关</a>  查壳反汇编不用说了，这道题是让你输入一些数字让程序最终执行到输出flag的函数<br>如果你游戏水平够高你也可以直接通过玩游戏来获取flag，不然的话还是修改汇编代码来的直接，找到main函数，在几个call  sub_45A7BE指令里面随便选一个修改为call  sub_45E940，保存运行即可，当然了前提是你能找到main函数和打印的flag的函数，再次运行exe文件即可得到flag</li></ul><p><img src="http://pic.yupoo.com/wfscjz/1639f889/big.png"></p><h2 id="安卓逆向"><a href="#安卓逆向" class="headerlink" title="安卓逆向"></a>安卓逆向</h2><h3 id="记一下自己逆向路上遇到的第一个安卓逆向题"><a href="#记一下自己逆向路上遇到的第一个安卓逆向题" class="headerlink" title="记一下自己逆向路上遇到的第一个安卓逆向题"></a>记一下自己逆向路上遇到的第一个安卓逆向题</h3><ul><li>题目时来自 <a href="https://ctf.bugku.com/">Bugku</a> 里的一入门题 <a href="https://ctf.bugku.com/challenges/detail/id/136.html">signin</a>,先在模拟器里面运行一下看看效果<br><img src="http://pic.yupoo.com/wfscjz/1ec16f3e/big.png"><br>猜测是一个输入字符然后验证的程序，我们用jeb打开apk文件，找到main函数按Q反编译成java代码<br><img src="http://pic.yupoo.com/wfscjz/eb4bfac8/big.png"><br>main函数里面的getFlag()函数是返回地址为2131427360处的字符串，然后该字符串在checkPassword函数中先被reverse翻转一下，然后base64解码，解码后的内容即为我们想要找的flag，所以问题变成了我们只需要找到地址为2131427360处的字符串即可<br>在apk文件的R类中可以找到地址为2131427360处的字符串命名为”toString”,在string类中，但是我在jeb里面没找到res/values文件夹，所以在百度搜索之后用jadx打开apk文件找到res/values/strings.xml<br><img src="http://pic.yupoo.com/wfscjz/94e4b629/big.png"></li><li>成功找到了字符串，所以后续我们写脚本跑一下即可<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">import</span> base64a <span class="token operator">=</span> <span class="token string">"991YiZWOz81ZhFjZfJXdwk3X1k2XzIXZIt3ZhxmZ"</span>a <span class="token operator">=</span> a<span class="token punctuation">[</span>::-1<span class="token punctuation">]</span>print<span class="token punctuation">(</span>base64.b64decode<span class="token punctuation">(</span>a<span class="token punctuation">))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Buuctf-Reverse3"><a href="#Buuctf-Reverse3" class="headerlink" title="Buuctf Reverse3"></a>Buuctf Reverse3</h2><ul><li><p>查壳扔进IDA反汇编如下<br><img src="https://i.loli.net/2021/12/01/EzD1lFLBG296OIf.png"></p></li><li><p>所以我们反过来求解即可，脚本如下</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">import</span> base64a <span class="token operator">=</span> <span class="token string">"e3nifIH9b_C@n@dH"</span>flag <span class="token operator">=</span> <span class="token string">""</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>a<span class="token punctuation">))</span>:  flag +<span class="token operator">=</span> chr<span class="token punctuation">(</span>ord<span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> - i<span class="token punctuation">)</span>print<span class="token punctuation">(</span>base64.b64decode<span class="token punctuation">(</span>flag<span class="token punctuation">))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Buuctf-不一样的flag"><a href="#Buuctf-不一样的flag" class="headerlink" title="Buuctf 不一样的flag"></a>Buuctf 不一样的flag</h2><ul><li>查壳，反汇编然后走迷宫<br><img src="https://i.loli.net/2021/12/01/i9azrYMSbB2FQxE.png"></li></ul><h2 id="Buuctf-simplere"><a href="#Buuctf-simplere" class="headerlink" title="Buuctf simplere"></a>Buuctf simplere</h2><ul><li>个人感觉这道题主要考察的是大端存储和小端存储，这个如果不知道的话那么这道肯定做不出来 <a href="https://baijiahao.baidu.com/s?id=1609459208102387514">计算机中数据存储方式</a><br>查壳，拖进IDA反汇编，找到Decry()函数<br><img src="https://i.loli.net/2021/12/02/IqpsuYS3KBOVCfv.png"><br>前面的部分主要是生成text和key字符串的，下面是验证输入的过程，所以我们可以写代码反推出flag<br><img src="https://i.loli.net/2021/12/02/xdyrqEYutk6QVHX.png">  </li><li>但是由于源程序代码中还有模26的操作，但我目前没想到更好的办法，所以只能让i从0到4开始爆破，i大于4时范围超了肯定不正确<pre class="line-numbers language-bash"><code class="language-bash">char text<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"killshadow"</span><span class="token punctuation">;</span>  char key<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"adsfkndcls"</span><span class="token punctuation">;</span>  char V1<span class="token punctuation">;</span>  char flag<span class="token punctuation">[</span>10<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  int V3 <span class="token operator">=</span> 10<span class="token punctuation">;</span>  for<span class="token punctuation">(</span> int i<span class="token operator">=</span>0<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>4<span class="token punctuation">;</span>i++<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      for<span class="token punctuation">(</span> int j<span class="token operator">=</span>0<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>10<span class="token punctuation">;</span>j++<span class="token punctuation">)</span>      <span class="token punctuation">{</span>          V1 <span class="token operator">=</span> text<span class="token punctuation">[</span>j<span class="token punctuation">]</span> - 97  + i * 26 + key<span class="token punctuation">[</span>V3++%10<span class="token punctuation">]</span> - 58<span class="token punctuation">;</span>          if<span class="token punctuation">(</span> V1 <span class="token operator">&lt;</span> 90 <span class="token operator">&amp;&amp;</span> V1 <span class="token operator">></span> 65 <span class="token punctuation">)</span>              flag<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> V1<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  cout <span class="token operator">&lt;&lt;</span> flag <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Buuctf-Java逆向解密"><a href="#Buuctf-Java逆向解密" class="headerlink" title="Buuctf Java逆向解密"></a>Buuctf Java逆向解密</h2><ul><li>附件是.class文件，所以直接用jd-gui打开<br><img src="https://i.loli.net/2021/12/02/djfN4bxquEDrHYv.png"></li><li>只是在数后面加上异或的值，java脚本如下</li></ul><pre><code>public static void main(String[] args) {        // TODO Auto-generated method stub        String flag = "" ;        int[] KEY = { 180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65 };        for (int j = 0; j &lt; KEY.length; j++) {          flag += (char)(KEY[j] - '@' ^ 0x20);        }        System.out.print(flag);    }</code></pre><h2 id="Buuctf-刮开有奖"><a href="#Buuctf-刮开有奖" class="headerlink" title="Buuctf 刮开有奖"></a>Buuctf 刮开有奖</h2><ul><li><p>一道输入flag然后对你的输入进行验证的题目，查壳，反汇编，找到关键的函数<br><img src="https://i.loli.net/2021/12/03/FbHoKOafIND7EWX.png"></p></li><li><p>在把sub_4010F0()中的代码转移到编译器里面自己执行时需要修改一些内容，首先(_DWORD <em>)要去除，然后就是</em>( i * 4 + a1)，点击v7,v8等等会发现它们的地址都是相差4，当然这是因为是32位程序导致的，如果是64位程序相差就位8.所以当i等于1时*(1 * 4 + a1) 对应的就是v8的值，是不是很像C++数组里面的 *（a + i ) ,所以在把代码转移到自己的编译器上时，你可以做如下修改 ：</p><p>1 将v7[0] 到 v16 的值用一个长度为11的数组表示</p><p>2 删去(_DWORD *) 和所有的 4 *</p></li><li><p>最后代码如下，跑一下就能出结果</p></li></ul><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;int __cdecl sub_4010F0(int *a1, int a2, int a3){  int result; // eax  int i; // esi  int v5; // ecx  int v6; // edx  result = a3;  for ( i = a2; i &lt;= a3; a2 = i )  {    v5 =  i;    v6 = a1[i];    if ( a2 &lt; result &amp;&amp; i &lt; result )    {      do      {        if ( v6 &gt; a1[result] )        {          if ( i &gt;= result )            break;          ++i;          a1[v5] = a1[result];          if ( i &gt;= result )            break;          while ( a1[i] &lt;= v6 )          {            if ( ++i &gt;= result )              goto LABEL_13;          }          if ( i &gt;= result )            break;          v5 =  i;          a1[result] = a1[i];        }        --result;      }      while ( i &lt; result );    }LABEL_13:    a1[result] = v6;    sub_4010F0(a1, a2, i - 1);    result = a3;    ++i;  }  return result;}int main(){    char flag[] = "WP1jMp" ; // v4 和 v5 base64解码    int arry[11] = {90,74,83,69,67,97,78,72,51,110,103};    sub_4010F0(arry,0,10) ;    cout &lt;&lt; "flag{" &lt;&lt; (char)(arry[0] + 34) &lt;&lt; char(arry[4]) &lt;&lt; flag &lt;&lt; "}" ;    return 0;}</code></pre><h2 id="Buuctf-luck-guy"><a href="#Buuctf-luck-guy" class="headerlink" title="Buuctf luck_guy"></a>Buuctf luck_guy</h2><ul><li>查壳，反汇编找到关键函数getflag()<br><img src="https://i.loli.net/2021/12/03/QbDg6eIymoC8XEw.png"></li><li>写代码跑一下即可,提交时把GXY换成flag即可</li></ul><pre><code>s = "icug`of"flag = "GXY{do_not_"for i in range(len(s)):    if i % 2 == 1:       flag += chr(ord(s[i]) - 2 )    else:       flag += chr(ord(s[i]) - 1 )print(flag)</code></pre><h2 id="Buuctf-JustRe"><a href="#Buuctf-JustRe" class="headerlink" title="Buuctf JustRe"></a>Buuctf JustRe</h2><ul><li>直接使用keypatch插件修改汇编代码让点击一次即可即可，当然你点击19999次也能出答案<br><img src="https://i.loli.net/2021/12/03/hSmrnbUAHuTtXCK.png"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向分析--对称加密RC4</title>
      <link href="/2021/01/17/ni-xiang-fen-xi-dui-cheng-jia-mi-rc4/"/>
      <url>/2021/01/17/ni-xiang-fen-xi-dui-cheng-jia-mi-rc4/</url>
      
        <content type="html"><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><ul><li>RC4是一种对称的流加密算法，它的密钥长度可变，通过随机数生成的核心与异或运算完成对于数据流的加密。相对于AES，DES对于固定长度数据块加密，RC4输入的plaintext为任意的。RC4的特点是运算速度快，密钥长度为1–256BYTE可变。<br>RC4的核心可以分为对密钥空间s的初始化与密文的交换。</li></ul><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ul><li>初始化S盒并用秘钥打乱S盒</li></ul><pre><code>void rc4_init(unsigned char*s,unsigned char*key,unsigned long len)//s最开始是传入的长度为256的char型空数组，用来存放初始化后的s//key是定义的秘钥  //最后一个len是密钥的长度{   int i=0;   int j=0;   unsigned char k[256]={};   unsigned char temp = 0;   for(i=0;i&lt;256;i++)    {       s[i]=i;         //0-255赋给s       k[i]=key[i%len];   //将k重新计算    }   for(i=0;i&lt;256;i++)   {      j=(j+s[i]+k[i])%256;    //给j赋      temp=s[i];      s[i]=s[j];      s[j]=temp;    //s[i]和s[j]交换   }}</code></pre><ul><li>加解密部分，因为是对称加密算法，所以既可加密也可解密</li></ul><pre><code>void rc4_crypt(unsigned char*s,unsigned char*data,unsigned long len)//s是上面初始化之后的，data是我们要加密的数据，len是data的长度{    int i=0,j=0,t=0;    unsigned long k=0;    unsigned char temp;    for(k=0;k&lt;len;k++)    {        i=(i+1)%256;            //固定方式        j=(j+s[i])%256;          //固定方式        temp=s[i];        s[i]=s[j];        s[j]=temp;             //s[i]和s[j]交换        t=(s[i]+s[j])%256;      //固定方式        data[k]^=s[t];          //异或运算，即加解密    }}</code></pre><ul><li>main函数</li></ul><pre><code>int main(){    unsigned char s[256] = {0};    unsigned char s2[256] = {0};    char key[256] = {"iloveyou"};    char data[512] = {"U2FsdGVkX1+WuEwk2Obam1iZnSWRLi8nKs0="};    unsigned long len = strlen(data);    rc4_init(s,(unsigned char*)key,strlen(key));    rc4_crypt(s,(unsigned char*)data,len);    cout &lt;&lt; data;    return 0;}</code></pre><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>介绍了这么多，主要是为了熟悉RC4加密的原理，但是真正在做题的时候还是直接去在线网站上解密RC4比较方便，除此之外，因为在逆向题目中RC4加密往往是调用某个函数来实现的，我们可以直接将这个函数复制到我们自己的编译器上跑一遍也能得出结果</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse Crypto </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
